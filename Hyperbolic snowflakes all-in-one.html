<!DOCTYPE html>
<!-- TODO: more detailed notes -->
<!--
  This code generates double square tiles, tilable snowflakes and allows drawing of symmetrical tilable shapes

  ComProp is short for the article "Combinatorial properties of double square tiles"

 -->
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>Hyperbolic Snowflakes</title>
  <style media="screen">
    /* TODO: fix unit clusterfuck (vh, rem, px) */

    body {
      /* background-color: rgb(10,15,30); */
      background-color: rgb(0,0,0);
      /* color: rgb(200, 200, 200); */
      /* color: rgb(10, 10, 10); */
      font-family: sans-serif;
      font-size: 2.5vh;  /* TODO: better with it? */
      overflow: hidden;
    }
    canvas {
      position: absolute;
      left: 0;
      top: 0;
    }
    div, span {
      color: white;
      /* padding: 5px 15px; */
      font-size: 16px;
      /* min-width: 90px; */
      /* min-height: 15px; */
      text-decoration: none;
      /* display: block; */
    }

    button {
      user-select: none;
    }
    .noSelect {
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
      -khtml-user-select: none; /* Konqueror HTML */
      -moz-user-select: none; /* Old versions of Firefox */
      -ms-user-select: none; /* Internet Explorer/Edge */
      user-select: none; /* Non-prefixed version, currently
      supported by Chrome, Edge, Opera and Firefox */
    }



    .drop-btn {/* Style The Dropdown Button */
      background-color: #237;
      /* background-color: #0000; */
      /* color: white; */
      /* padding: 0; */
      /* font-size: 16px; */
      width: 30px;
      height: 30px;
      border: none;
      cursor: pointer;
      position: absolute;
      left: 0;
      top: 0;
      padding: 0;
      /* font-size: 30px; */
      font-size: 20px;
    }

    .dropdown {/* The container div - needed to position the dropdown content */
      position: absolute;
      left: 10px;
      top: 10px;
      display: inline-block;
      background-color: #2228;
      /* outline: 2px solid black; */
    }

    .dropdown-content {/* Dropdown Content (Hidden by Default) */
      display: none;
      /* display: inline-block; */ /* uncomment this to make the dropdown content always visible */
      /* position: absolute; */
      /* background-color: #237; */
      /* box-shadow: 0px 8px 16px 0px #0004); */
      /* padding: 6px 0px; */
      z-index: 1;
      vertical-align: top;
    }

    /* .dropdown-content div {/* Links inside the dropdown */

    /*.dropdown-content div:hover {background-color: #335}/* Change color of dropdown links on hover */


    .dropdown:hover .drop-btn {/* Hide the dropdown button while dropdown is being hovered */
      display: none;
    }
    .dropdown:hover .dropdown-content {/* Display the dropdown content while the dropdown is being hovered */
      display: inline-block;
    }

    .simple-button {
      background-color: #237;
    }
    .simple-button:hover {
      background-color: #124;
    }

    #draw-size-container {
      padding: 0;
      background-color: transparent;
    }
    .draw-size-option {
      padding: 5px 10px;
    }

    #mirror-angle-setting-container {
      margin-bottom: 1.5%;
    }

    .mirror-angle-input-option {
      /* outline: 1px solid black; */
      border-radius: 6px 6px 0 0;
      margin-right: 1px;
      padding: 5px 3.5% 1.5% 3.5%;
    }

    .mirror-angle-number-input {
      width: 30%;
      margin-left: 3px;
      margin-right: 3px;
    }
    .mirror-angle-number-input-container {
      /* outline: 2px dashed yellow; */
      /* width: 200%; */ /* TODO: this doesn't work */
      display: none;
      background-color: #237;
      border-radius: 0 0px 6px 6px;
      padding: 5px 15px;
    }

    #mirror-angle-value-container {
      color: white;
      /* padding: 15px 5px; */
      /* margin-top: 4px; */
      margin-bottom: 2%;
    }

    #tiling-type-input {
      color: white;
    }

    #auto-generate-valid-snowflake {
      border: 1px solid #777;
      border-radius: 3px;
      background-color: #eee;
      color: black;
      padding: 1% 2%;
    }
    #auto-generate-valid-snowflake:disabled,
    #auto-generate-valid-snowflake[disabled] {
      /* border-color: #777;
      background-color: #ddd;
      color: #aaa; */
      opacity: 0.5;
    }
    #auto-generate-valid-snowflake:hover {
      background-color: #ddd;
    }
    #auto-generate-valid-snowflake:active {
      background-color: #ccc;
      padding: 1.3% 2% 0.7% 2%;/* TODO: probably not a good idea */
      /* border-width: 3px; */
    }


    #use-mirrors-button {
      padding: 0.8% 4%;
      color: white;
      border-radius: 0.25rem;
      text-align: center;
      width: 25%;
    }

    .color-select-option {
      width: 13vw;
      height: 3.5vh;
    }



    .uiContainer {
      text-align: right;

      /* font-family: cursive; */
      /* position: absolute; */
      left: 1.6vh;
      top: 1.6vh;
      z-index: 2;
      background-color: hsl(0,0%,30%);
      padding: 1vh;
      border-radius: 1vh;
      line-height: 3.5vh;
      overflow: auto;
      margin-bottom: 1rem;
      color: rgb(200, 200, 200);
    }
    .uiSubContainer {
      text-align: left;
      background-color: hsl(0,0%,85%);
      padding: 0.6vh;
      margin: 0.3vh;
      border-radius: 0.6vh;
      color: rgb(10, 10, 10);
    }

    .gameSettingsNumbers {
      width: 4.5vh;
      /* background-color: hsl(0,0%,75%); */
      background-color: inherit;
      border-radius: 0.4vh;
      border: 1px solid gray;
    }
    .inlineNumber {
      display: inline;
    }
    #schlafli-input-container {
       padding-bottom:3px;
       padding-top:3px;
       color: black;
    }

  </style>
</head>
<body>
  <canvas id="canvas" width="300" height="300"></canvas>
  <canvas id="changing-canvas" width="300" height="300"></canvas>

  <div class="dropdown">
    <button id="drop-btn" class="drop-btn"></button>



    <div class="dropdown-content" id="color-select-dropdown"></div>
    <!-- <div class="dropdown-content" style="width:40vw"> -->
    <div class="dropdown-content">
      <div id="draw-size-container" style="margin-bottom: 1.8vh;"><!-- pen size -->
        <span class="simple-button draw-size-option" onclick="drawSize=1">1px</span>
        <span class="simple-button draw-size-option" onclick="drawSize=3">3px</span>
        <span class="simple-button draw-size-option" onclick="drawSize=10">10px</span>
        <span class="simple-button draw-size-option" onclick="drawSize=30">30px</span>
      </div>
      <span id="word-mode-button" style="display:inline-block" onclick="invertWordModeEnabled()"></span>
      <hr>
      <span id="use-mirrors-button" style="display:inline-block" onclick="invertUseMirrors()"></span>
      <div id="word-mode-container">
        <span>Operations </span><input type="text" id="dsf-operations-input" autocomplete="off" onchange="updateCurDSFOperations()"><br>
        <div>Input a string of the operations s0, s1, e0, e1, t0, t1, T, d</div>
        <span>|w<sub>0</sub>|=</span><span id="w0-length-display"></span><br>
        <span>|w<sub>1</sub>|=</span><span id="w1-length-display"></span><br>
      </div>
      <div id="drawing-mode-container">
        <div id="mirror-angle-container">
          <div id="mirror-angle-setting-container" style="padding-left: 0; padding-bottom:5px; padding-top: 2%"></div><!-- which mirror angle input setting to use (slope, deg, rad...) -->
          <div id="mirror-angle-value-container" style="padding-left: 0"></div>
        </div>
        <button style="font-size:16px" id="auto-generate-valid-snowflake" onclick="autoGenerateVertexesGeometrically()">Auto-generate geometrically</button>
      </div>
      <form style="margin-bottom: 3%" id="tiling-type-input" onchange="updateTilingType()"></form>

      <hr>

      <div class="dropdown-content uiContainer">
        <div class="uiSubContainer">
          <span id="schlafli-input-container"><b>{<input class="gameSettingsNumbers" type="number" id="schlafliP" name="schlafliP" min="3" max="30">; <input class="gameSettingsNumbers" type="number" id="schlafliQ" name="schlafliQ" min="3" max="30">}</b></span> grid<br>
          <button onclick="updateSchlafliSymbol()"><b>Go</b></button>
        </div>
      </div>
    </div>
  </div>
  
  <script type="text/javascript">
    "use strict";
    function rand(max=1) {
      return Math.random()*max;
    }
    function rand0(max=1) {
      return (Math.random()-0.5)*max*2;
    }
    function randInt(max=2) {
      return Math.floor(Math.random()*max);
    }
    function randProb(p=0.5) {
      return p>Math.random();
    }
    function randRange(a, b) {
      return Math.random()*(b-a)+a;
    }
    function clamp(num, val=1) {//num to clamp, special value
      return 1-(val/(num+val));
    }
    function colorLerp(n1, n2, x=0.5) {
      return n2.sub(n1).mult(x).add(n1);
    }
    function cutoff(x, min, max) {
      if (min!=undefined && x<min) {
        return min;
      }
      if (max!=undefined && x>max) {
        return max;
      }
      return x;
    }
    function closenessPenalty(x, coefficient) { //what number to divide x by so it doesn't reach 1
      return 1-coefficient-coefficient/(x-1);
    }
    function round(v, p=2) {
      return Math.round(v*10**p+Number.EPSILON)/10**p;
    }
    function lerp(x, v1, v2) {
      return x*(v2-v1)+v1;
    }
    function map(x, a1, a2, b1, b2) {
      return (x-a1)/(a2-a1)*(b2-b1)+b1;
    }
    function arrayContains(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i]==val) return true;
      }
      return false;
    }
    function indexOfElement(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i]==val) return i;
      }
    }
    function arraysShallowEqual(a, b) {
      var i = a.length;
      if (i != b.length) return false;
      while (i--) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    };
    function arrayPush(arr, el) {//pushes el to arr and returns arr
      arr.push(el);
      return arr;
    }
    function mod(v, m) {//%, but works properly with negative numbers
      return (v%m+m)%m;
    }

    /* TODO:
      a bunch of attribution is still needed
      replace a bunch of 0.001 epsilons
      word ui
      just drawing previews is demanding? (canvas transformations might help???)
      detailed drawing mode (zoom in on one fundamental triangle)
      better, more efficient undo (could fairly easily be much more efficient one level deep)
      better UI
      find all TO-DOs
      better resizing
      erase pointless commented code
      change page title?
      refactor all the things
      replace var with let?
    */


    var canvas=document.getElementById("canvas");
      var context=canvas.getContext("2d");
      
      var changingCanvas=document.getElementById("changing-canvas");
      var changingContext=changingCanvas.getContext("2d");
      var dropBtn=document.getElementById("drop-btn");
      var useMirrorsButton=document.getElementById("use-mirrors-button");
      var autoGenerateButton=document.getElementById("auto-generate-valid-snowflake");
      var mirrorAngleContainer=document.getElementById("mirror-angle-container");
      var dsfOperationsInput=document.getElementById("dsf-operations-input");
      var w0LengthDisplay=document.getElementById("w0-length-display");
      var w1LengthDisplay=document.getElementById("w1-length-display");
      
      var wordModeButton=document.getElementById("word-mode-button");
      var wordModeContainer=document.getElementById("word-mode-container");
      var drawingModeContainer=document.getElementById("drawing-mode-container");
      
      var schlafliInputContainer=document.getElementById("schlafli-input-container");
      var schlafliPInput=document.getElementById("schlafliP");
      var schlafliQInput=document.getElementById("schlafliQ");
      
      const TAU=2*Math.PI;
        const PI=Math.PI;
        const HPI=Math.PI/2;
        const PHI=(Math.sqrt(5)+1)/2;
        const ROOT2=Math.sqrt(2);
        const ROOT3=Math.sqrt(3);
        const HALFROOT3=Math.sqrt(3)/2;
      var paused=false;
      var frameSkip= 1 ;
      // var frameSkip= 20 ;
      var fReqs=frameSkip;
      var colorChangeSteps=0;
      var keys=[];
      var mousePos=new Vec2();
      var mouseDown=false;
      var height=100;// TODO: do similarly for width?
      
      
      var mousePositions=[];//mouse locations as Vec2 for individual points
      var movements=[];      //
      var movementColors=[]; //
      var movementSizes=[];  // TODO: make these 3 into an object array
      var curMovement=-1;//index of which movement (in the movements array) is currently happening or which has last been finished
      // var globalScaling=0.2;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      // var globalScaling=0.5;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      // var globalScaling=0.8;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      // var globalScaling=1;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      var globalScaling;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      var DSFGridScaling=0.85;//applies to generateDSFGrid
      const minFramesSinceResize=20;//if the window is being constantly resized (slow dragging), resize the canvas every minFramesSinceResize frames
      var framesSinceResize=0;
      var resizeRequested=false;//has the window been resized while the canvas hasn't yet?
      const mouseSlowingFactor=1.5;//0-infinity, sets how much mouse movement is smoothed out, see equation in mousemove event
      var drawSize=1;// TODO: should be relative to some unit, otherwise scaling messes up filled regions
      
      // var schlafliSymbol=[6, 3];
      // var schlafliSymbol=[3, 6];
      // var schlafliSymbol=[4, 6];
      // var schlafliSymbol=[6, 4];
      // var schlafliSymbol=[5, 4];
      var schlafliSymbol=[4, 4];
      // var schlafliSymbol=[4, 7];
      // var schlafliSymbol=[7, 3];
      // var schlafliSymbol=[10, 3];
      // var schlafliSymbol=[4, 3];
      // var schlafliSymbol=[5, 3];
      // var schlafliSymbol=[3, 4];
      
      var schlafliP=schlafliSymbol[0];
      var schlafliQ=schlafliSymbol[1];
      
      // var tilingTypeName="none";
      // var tilingTypeName="hypTest";
      var tilingTypeName="regular using schlafli";
      // var tilingTypeName="anisohedral";
      
      // var tilingTypes=[["none"], ["hypTest"], ["regular using schlafli"], ["anisohedral"]];
      var tilingTypes=[["none", "single tile"], ["regular using schlafli", "tiling"]];
      // var tilingTypeName=tilingTypes[tilingTypeIndex][0];
      
      // var tilingTypeName;
      var tilingTypeIndex;
      for (var i = 0; i < tilingTypes.length; i++) {
        let t=tilingTypes[i];//the current tiling type
        document.getElementById("tiling-type-input").innerHTML+="<input id='tiling-type-"+i+"' type='radio' name='tiling-type' value='"+t[0]+"'><label for='tiling-type-"+i+"'>"+t[1]+"</label>";// TODO: too long
        
        if (tilingTypes[i][0]==tilingTypeName) {//set tilingTypeIndex
          tilingTypeIndex=i;
        }
      }
      document.getElementById("tiling-type-"+tilingTypeIndex).checked=true;
      
      var initialDrawingReady=false;
      
      var useMirrors;//the tile is either mirror symmetrical (true) or chiral (false)
      function setUseMirrors(u) {
        if (useMirrors!==u) {
          useMirrors=u;
          if (useMirrors) {
            useMirrorsButton.style.backgroundColor="#16f";
            useMirrorsButton.innerHTML="Dihedral";
            mirrorAngleContainer.style.opacity=1;
          }
          else {
            useMirrorsButton.style.backgroundColor="#666";
            useMirrorsButton.innerHTML="Chiral";
            mirrorAngleContainer.style.opacity=0.5;
          }
          setInTileTransforms();
          clearAll();
          updateAutoGenerateButton();
        }
      }
      function invertUseMirrors() {
        setUseMirrors(!useMirrors);
      }
      setUseMirrors(true);
      
      var wordModeEnabled;//the tile is either mirror symmetrical (true) or chiral (false)
      function setWordModeEnabled(u) {
        if (wordModeEnabled!==u) {
          wordModeEnabled=u;
          if (wordModeEnabled) {
            wordModeButton.style.backgroundColor="#16f";
            wordModeButton.innerHTML="Word mode";
            // wordModeContainer.style.visibility="visible";
            // drawingModeContainer.style.visibility="hidden";
            wordModeContainer.style.display="block";
            drawingModeContainer.style.display="none";
            // setTilingTransforms("regular using schlafli");// TODO: would modifying the function and using this be better (otherwise i need an extra line to change tilingTypeName)
            tilingTypeName="regular using schlafli";
            setTilingTransforms();
            setDSFStuff();
          }
          else {
            wordModeButton.style.backgroundColor="#666";
            wordModeButton.innerHTML="Drawing mode";
            // wordModeContainer.style.visibility="hidden";
            // drawingModeContainer.style.visibility="visible";
            wordModeContainer.style.display="none";
            drawingModeContainer.style.display="block";
            // setTilingTransforms("regular using schlafli");
            updateTilingType();
            setTilingTransforms();
            updateMirrorAngle();
          }
          updateAutoGenerateButton();
          // if (initialDrawingReady) {
            clearAll();
          // }
        }
      }
      function invertWordModeEnabled() {
        setWordModeEnabled(!wordModeEnabled);
      }
      
      var curMirrorAngleInput=0;
      var mirrorAngleInputOptionsArr=[//[symbol in selection tab, function to make the input into a slope, text before input box, text after input box]
        ["k=√3/x", function(x){ return ROOT3/x; }, "Slope=√3/", ""],
        ["k=x", function(x){ return x; }, "Slope=", ""],
        ["θ=x <i>rad</i>", function(x){ return Math.tan(x); }, "Angle=", "<i>rad</i>"],
        ["θ=x°", function(x){ return Math.tan(x/360*TAU); }, "Angle=", "°"]
      ]
      function setCurMirrorAngleInput(curInput=0) {
        curMirrorAngleInput=curInput;
        for (var i = 0; i < mirrorAngleInputOptionsArr.length; i++) {
          document.getElementById("mirror-angle-number-input-container-"+i).style.display="none";
          document.getElementById("mirror-angle-input-option-"+i).style.backgroundColor="#124";
        }
        document.getElementById("mirror-angle-number-input-container-"+curMirrorAngleInput).style.display="inline";
        document.getElementById("mirror-angle-input-option-"+curMirrorAngleInput).style.backgroundColor="#237";
        updateMirrorAngle();
      }
      for (var i = 0; i < mirrorAngleInputOptionsArr.length; i++) {
        // TODO: adding big elements through js, not pretty
        //add tabs which can be clicked to select the way the mirror angle is inputted
        document.getElementById("mirror-angle-setting-container").innerHTML+="<span class='mirror-angle-input-option' id='mirror-angle-input-option-"+i+"' onclick='setCurMirrorAngleInput("+i+")'>"+mirrorAngleInputOptionsArr[i][0]+"</span>";
        //add containers with a number input and a description of how it is turned into the mirror angle. They're on top of eachother and not displayed by default
        document.getElementById("mirror-angle-value-container").innerHTML+="<div class='mirror-angle-number-input-container' id='mirror-angle-number-input-container-"+i+"'>"+mirrorAngleInputOptionsArr[i][2]+"<input class='mirror-angle-number-input' id='mirror-angle-number-input-"+i+"' type='number' step='any' value='15' onchange='updateMirrorAngle()'>"+mirrorAngleInputOptionsArr[i][3]+"<br>";// TODO: better default values
      }
      setCurMirrorAngleInput();
      
      function canAutoGenerateGeometrically() {
        // return useMirrors && (// TODO: can i use this?
        //   (schlafliP==6 && schlafliQ==3) ||
        //   (schlafliP==4 && schlafliQ==4)
        // );
        return schlafliP==6 && schlafliQ==3 && useMirrors && tilingTypeName=="regular using schlafli";
      }
      function updateAutoGenerateButton() {//update whether the tiling auto-generation button can be clicked or is greyed out
        let clickability=canAutoGenerateGeometrically();
        autoGenerateButton.disabled=!clickability;
      }
      
      var P=[];//Polygons array
        var V=[];//Vertexes array
        var numPolys=0;
        var numVerts=0;
        schlafliPInput.value=schlafliP;
        schlafliQInput.value=schlafliQ;
        var numTakenVerts=0;
        var lastClickTookPolygon=false;
        var isEuclidean;// TODO: not needed
        var curvature;
        
        var edgeLengthHyp;
        var centerToEdgeMidpointEuc;
        var centerToEdgeMidpointHyp;
        var centerToVertexEuc;//hyp distance from the center of a tile to its vertex, for the tiling given by schlafliSymbol
        var centerToVertexHyp;
        
        var hypPolyVertRadius= 0.15 ;
        var hypPolyEdgeWidth= 0.03 ;
        
        var globalEdgeAngleOffset;
        
        function distortion(vec) {
          return vec;//do nothing function
          // return new Vec2(Math.sin(vec.x*HPI), Math.sin(vec.y*HPI));
          // let dist=vec.len();
          // return vec.mult( Math.sin(dist*HPI) /dist);
          // return vec.mult( Math.asin(dist)/HPI /dist);
        }
    

    function wordPeriodLen(w) {
      let period=1;
      let periodFound=false;
      for (; period < w.length+1; period++) {
        periodFound=true;
        for (var j = period; j < w.length; j++) {
          if (w[j-period]!=w[j]) {
            periodFound=false;
            break;
          }
        }
        if (periodFound) {
          break;
        }
      }
      return period;
    }
    function wordUV(w) {// TODO: delete after making analogous method of DSF
      let period=wordPeriodLen(w);

      let uLen=w.length % period;
      let newW=w.slice();
      let u=newW.splice(0, uLen);
      let v=newW.slice(0, period-uLen);

      return {u: u, v: v};
    }
    function wordRho(r, w) {//rotate the word w by r (add r to each element, modulo the schlafliP)
      let res=[];
      for (var i = 0; i < w.length; i++) {
        // res[i]=((w[i]+r)%schlafliP+schlafliP)%schlafliP;
        res[i]=w[i]+r;// TODO: is it really this simple to make the tiles work with negative numbers?! this will have to be noted
      }
      return res;
    }
    function wordSplitUVAndVU(uv, vu) {//input: uv and vu; output: u and v (// TODO: only hopefully, need to check better)
      if (uv.length==vu.length) {
        let d=uv.length;
        let i=0;
        for (; i < d; i++) {
          let done=true;
          for (var j = i; j < d; j++) {
            if (uv[j-i]!=vu[j]) {
              done=false;
              break;
            }
          }
          if (done) break;
        }
        let u=uv.slice(0, d-i);
        let v=vu.slice(0, i);
        if (!arraysShallowEqual(u.slice().concat(v), uv) || !arraysShallowEqual(v.slice().concat(u), vu)) {
          console.warn("wordSplitUVAndVU failed");
          console.log("i", i, "uv", uv, "vu", vu);
          console.log("u", u, "v", v);
        }
        return {u:u, v:v};
      }
      alert("alert005 wordSplitUVAndVU bad input");
      return {u:[], v:[]};
    }
    function DSF(w0, w1, operatorTrace=[]) {//class for a modification of a double square factorization (restricted with symmetry but generalized with different tilings TODO: it's not really DSF, but some modification/generalization of it, i should rename the class). most of the algorithms here are from ComProp
      // TODO: this is a wall of code
      // TODO: add a schlafliP property (because maybe i want to generate and display tiles that aren't selected for user drawing)
      this.w0=w0.slice();
      this.w1=w1.slice();
      this.segmentLength=1;
      this.operatorTrace=operatorTrace;//an array with the names of the functions that generated this DSF (eg. ["extend1", "extend0", "swap0"])
      this.getWord=function(i) {// TODO: untested and unused
        if ((i%2+2)%2==0) {
          return wordRho(i/2, w0);
        }
        else if ((i%2+2)%2==1) {
          return wordRho((i-1)/2, w1);
        }
        else {
          alert("alert004 i isn't an integer");
          return [];
        }
      }
      this.getEdgeWord=function() {//get w0 concat w1  (the edge)
        return w0.concat(this.w1);
      }
      this.getBoundaryWord=function() {//get w0 concat w1 concat wordRho(1, w0) concat wordRho(1, w1) ...  (the whole boundary)
        let edgeWord=this.getEdgeWord();
        let res=edgeWord.slice();//copy of edgeWord
        for (var i = 1; i < schlafliP; i++) {
          for (var j = 0; j < edgeWord.length; j++) {// TODO: use wordRho instead of extra loop
            res.push((edgeWord[j]+i)%schlafliP);
          }
        }
        return res;
      }
      this.getEdgeVector=function() {//get the displacement vector of the path of one edge (assuming 0 means rightwards and every segment is of unit length)
        let edgeVector=new Vec2();
        let edgeWord=this.getEdgeWord();
        for (var i = 0; i < edgeWord.length; i++) {
          edgeVector=new Vec2(edgeVector.x+Math.cos(edgeWord[i]*TAU/schlafliP), edgeVector.y-Math.sin(edgeWord[i]*TAU/schlafliP));
        }
        return edgeVector;
      }
      this.getMaxDistFromCenter=function() {//distance from the farthest vertex to the center of the tile
        let edgeVec=this.getEdgeVector();
        let center=edgeVec.rotate(HPI-PI/schlafliP).mult(1/(2*Math.sin(PI/schlafliP)));//vector to the center of the tile
        // console.log(edgeVec, center);
        // console.log(edgeVec.len()/center.len());
        // console.log(center.ang()-edgeVec.ang());
        let edgeWord=this.getEdgeWord();
        let curPos=new Vec2();
        let maxSqDist=0;
        for (var i = 0; i < edgeWord.length; i++) {
          curPos=new Vec2(curPos.x+Math.cos(edgeWord[i]*TAU/schlafliP), curPos.y-Math.sin(edgeWord[i]*TAU/schlafliP));
          let curSqDist=curPos.sqDist(center);
          if (maxSqDist<curSqDist) maxSqDist=curSqDist;
        }
        return Math.sqrt(maxSqDist);
      }
      this.len=function() {
        return 6*(this.w0.length+this.w1.length);
      }
      this.opTracePush=function(op) {//returns a copy of this.operatorTrace with an extra element (op)
        let trace=this.operatorTrace.slice();
        trace.push(op)
        return trace;
      }
      
      this.getU0V0=function() {// TODO: basically like getu1v1, simplify!
        // if (this.w1.length!=0) {// TODO:
        let w1=this.w1.slice();
        let wNegative1=wordRho(-1, w1);
        let uv=w1.slice().reverse().concat(wNegative1);
        let vu=w1.slice().concat(wNegative1.slice().reverse());
        
        let fromSplitFunc=wordSplitUVAndVU(uv, vu);
        
        if (!arraysShallowEqual(fromSplitFunc.u.slice().concat(fromSplitFunc.v), uv) || !arraysShallowEqual(fromSplitFunc.v.slice().concat(fromSplitFunc.u), vu)) {// TODO:
          console.log("");
          console.warn("alert002 getU0V0");
          // alert("alert002 getU0V0");
          
          let fromFunc=wordUV(this.w0);
          let uvGGG=wordRho(1, this.w0).reverse().concat(this.w0);
          let vuGGG=wordRho(1, this.w0).concat(this.w0.slice().reverse());
          // console.log("check in getU0V0", fromFunc.u.slice().concat(fromFunc.v), uvGGG, "and", fromFunc.v.slice().concat(fromFunc.u), vuGGG);
          if (!arraysShallowEqual(fromFunc.u.slice().concat(fromFunc.v), uvGGG) || !arraysShallowEqual(fromFunc.v.slice().concat(fromFunc.u), vuGGG)) {// TODO:
            console.log("");
            console.warn("alert003 getU0V0");
            // alert("alert002 getU1V1");
          }
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {// TODO: not a good check
            return fromFunc;
          }
          return fromFunc;
        }
        // console.log("i", i, "u0v0", uv, "v0u0", vu);
        return {u:fromSplitFunc.u, v:fromSplitFunc.v};
      }
      this.getU1V1=function() {
        // if (this.w1.length!=0) {// TODO:
        let w0=this.w0.slice();
        let w2=wordRho(1, w0);
        let uv=w2.slice().reverse().concat(w0);
        let vu=w2.slice().concat(w0.slice().reverse());
        
        let fromSplitFunc=wordSplitUVAndVU(uv, vu);
        
        if (!arraysShallowEqual(fromSplitFunc.u.slice().concat(fromSplitFunc.v), uv) || !arraysShallowEqual(fromSplitFunc.v.slice().concat(fromSplitFunc.u), vu)) {// TODO:
          console.log("");
          console.warn("alert002 getU1V1");
          // alert("alert002 getU1V1");
          
          let fromFunc=wordUV(this.w1);
          let uvGGG=wordRho(1, this.w0).reverse().concat(this.w0);
          let vuGGG=wordRho(1, this.w0).concat(this.w0.slice().reverse());
          // console.log("check in getU1V1", fromFunc.u.slice().concat(fromFunc.v), uvGGG, "and", fromFunc.v.slice().concat(fromFunc.u), vuGGG);
          if (!arraysShallowEqual(fromFunc.u.slice().concat(fromFunc.v), uvGGG) || !arraysShallowEqual(fromFunc.v.slice().concat(fromFunc.u), vuGGG)) {// TODO:
            console.log("");
            console.warn("alert003 getU1V1");
            // alert("alert002 getU1V1");
          }
          // console.log(fromFunc);
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {// TODO: not a good check
            return fromFunc;
          }
          return fromFunc;
        }
        // console.log("i", i, "u1v1", uv, "v1u1", vu);
        return {u:fromSplitFunc.u, v:fromSplitFunc.v};
      }
      this.getU0ConcatV0=function() {
        if (this.w1.length!=0) {
          return this.w1.slice().reverse().concat(wordRho(-1, this.w1));
        }
        else {
          let fromFunc=wordUV(this.w0);
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {
            return fromFunc.u.concat(fromFunc.v);
          }
          else {
            alert("alert005 kinda bad but mainly bad input");
            console.log("alert005 kinda bad but mainly bad input");
            return [];
          }
        }
        
        // let fromFunc=wordUV(this.w0);
        // // console.log(fromFunc);
        // if (fromFunc.u.length>0 && fromFunc.v.length>0) {
        //   return fromFunc.u.concat(fromFunc.v);
        // }
        // else if (this.w1.length!=0) {
        //   return this.w1.slice().reverse().concat(wordRho(-1, this.w1));
        // }
        // // else {// TODO: i think this is only in the case of a hexagon
        // //   console.log("vvvv");
        // //   return wordRho(1, this.w1).concat(this.w1);
        // // }
        // console.log("bad");// TODO: temporary
        // return fromFunc;// TODO: temporary
      }
      this.getU1ConcatV1=function() {
        if (this.w0.length!=0) {
          return wordRho(1, this.w0).reverse().concat(this.w0);
        }
        else {
          let fromFunc=wordUV(this.w1);
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {// TODO: ????? is this a good check? i don't think so
            return fromFunc.u.concat(fromFunc.v);
          }
          else {
            alert("alert005 kinda bad but mainly bad input");
            console.log("alert005 kinda bad but mainly bad input");
            return [];
          }
        }

        // let fromFunc=wordUV(this.w1);
        // // console.log(fromFunc);
        // if (fromFunc.u.length>0 && fromFunc.v.length>0) {
        //   return fromFunc.u.concat(fromFunc.v);
        // }
        // else if (this.w0.length!=0) {
        //   return wordRho(1, this.w0).reverse().concat(this.w0);
        // }
        // // else {// TODO: i think this is only in the case of a hexagon
        // //   console.log("vvvv");
        // //   return this.w0.slice().concat(wordRho(1, this.w0));
        // // }
        // console.log("bad");// TODO: temporary
        // return fromFunc;// TODO: temporary
        //
        // // let fromFunc=wordUV(this.w1);
        // // console.log(fromFunc);
        // // if (fromFunc.u.length>0 && fromFunc.v.length>0) {
        // //   console.log("|u1|, |v1| > 0");
        // //   return fromFunc.u.concat(fromFunc.v);
        // // }
        // // else {
        // //   console.log("|u1| or |v1| == 0");
        // //   if (this.w0.length!=0) {
        // //     console.log("|w0| > 0");
        // //     return wordRho(1, this.w0).reverse().concat(this.w0);
        // //   }
        // //   else {
        // //     console.log("|w0| == 0");
        // //   }
        // // }
        // // // else {// TODO: i think this is only in the case of a hexagon
        // // //   console.log("vvvv");
        // // //   return this.w0.slice().concat(wordRho(1, this.w0));
        // // // }
        // // console.log("bad");// TODO: temporary
        // // return fromFunc;// TODO: temporary
      }
      
      this.trim0=function() {
        let newW0=this.w0.slice(0, -wordPeriodLen(this.w0));// TODO: will this always work?
        return new DSF(newW0, this.w1, this.opTracePush("trim0"));
      }
      this.trim1=function() {
        let newW1=this.w1.slice(0, -wordPeriodLen(this.w1));
        return new DSF(this.w0, newW1, this.opTracePush("trim1"));
      }
      this.trimIfPossible=function() {
        if (this.w0.length>2*this.w1.length && this.w1.length>0) {
          return this.trim0();
        }
        else if (this.w1.length>2*this.w0.length && this.w0.length>0) {
          return this.trim1();
        }
        else {
          return this;
        }
      }
      this.swap0=function() {
        let newW0=this.w0.slice().reverse();
        let uv=this.getU1V1();
        let newW1=this.w1.slice(uv.u.length).concat(uv.v);
        return new DSF(newW0, newW1, this.opTracePush("swap0"));
      }
      this.swap1=function() {
        let newW1=this.w1.slice().reverse();
        let uv=this.getU0V0();
        let newW0=this.w0.slice(uv.u.length).concat(uv.v);
        return new DSF(newW0, newW1, this.opTracePush("swap1"));

        // TODO: use rotation for all duplicate actions?
        // let rotatedResult=new DSF(this.w1, wordRho(1, this.w0)).swap0();
        // return new DSF(rotatedResult.w1, wordRho(1, rotatedResult.w0));// TODO: rotating forwards a second time, should rotate back? DSF(rho(-1, w1), w0) or smth like that
      }
      this.extend0=function() {
        if (this.w1.length==0) {
          console.log("bad input to extend");
          return new DSF([], [], this.opTracePush("extend0"));
        }
        else {
          // let onePeriod=this.w0.slice(0, wordPeriodLen(this.w0));
          // return new DSF(onePeriod.concat(this.w0), this.w1);
          // let u0v0=this.getU0V0();
          // return new DSF(this.w0.concat(u0v0.v).concat(u0v0.u), this.w1);
          // console.log("u0*v0", this.getU0ConcatV0());
          return new DSF(this.getU0ConcatV0().concat(this.w0), this.w1, this.opTracePush("extend0"));
        }
      }
      this.extend1=function() {
        if (this.w0.length==0) {
          console.log("bad input to extend");
          return new DSF([], [], this.opTracePush("extend1"));
        }
        else {
          // let onePeriod=this.w1.slice(0, wordPeriodLen(this.w1));
          // return new DSF(this.w0, onePeriod.concat(this.w1));
          return new DSF(this.w0, this.getU1ConcatV1().concat(this.w1), this.opTracePush("extend1"));
        }
      }
      this.dual=function() {//the chiral dual of this DSF, essentally mirroring across one of the tilings' mirrors
        // return new DSF(this.w1.slice().reverse(), this.w0.slice().reverse(), this.opTracePush("dual"));//doesn't change appearance, might be useful
        return new DSF(this.w1, wordRho(1, this.w0), this.opTracePush("dual"));
      }
      this.reduceHoweverPossible=function() {// TODO:
        // if (w0) {
        //
        // }
      }
      
      this.getMirrorSlope=function() {
        let curPos=new Vec2();
        
        let w0=this.w0;
        let runningLen=0;
        let runningAng=0;
        let innerTurnAngBonus=0;
        // for (var j = 0; j < schlafliP; j++) {
        for (var i = 0; i < w0.length; i++) {
          let innerTurnAng=0;
          if (i!=0) {//certain things (like getting the previous segment) will only work if this is not first segment
            innerTurnAng=TAU * (w0[i]-w0[i-1])/schlafliQ;//the angle between the current and previous segments // TODO: i don't fully understand why this works (why eW[i]-eW[i-1] is 1 or -1)
          }
          let innerTurnAngWithBonus=innerTurnAng-innerTurnAngBonus;
          
          // do some trigonometry (using https://en.wikipedia.org/wiki/Hyperbolic_triangle TODO: cite better) to find unknowns in the triangle {old displacement Vector, current path segment, new displacement vector} with angles {new innerTurnAngBonus, runningAngChange, old innerTurnAngWithBonus}
          
          // TODO: make these 3 into one function? (maybe not needed, but there's a lot of copying with slight modifications)
          innerTurnAngBonus=hypSASGetAngleAtFirstSide(this.segmentLength, innerTurnAngWithBonus, runningLen);
          let newRunningLen=hypSASGetThirdEdge(runningLen, innerTurnAngWithBonus, this.segmentLength);
          let runningAngChange=hypSASGetAngleAtFirstSide(runningLen, innerTurnAngWithBonus, this.segmentLength); //how much needs to be added to the running angle. it is equal to the angle between the new and old running-displacement-vectors
          
          runningAng+=runningAngChange;
          runningLen=newRunningLen;
        }
        
        let newMirrorM=Math.tan(hypSASGetAngleAtFirstSide(centerToVertexHyp, PI/schlafliQ+globalEdgeAngleOffset-runningAng, runningLen)/2);
        return newMirrorM;
      }
      this.updateMirrorM=function() {// TODO: generalize path calculations into a seperate function, they're already used in 3 DSF methods
        // console.log("updateMirrorM");
        updateMirrorAngle(this.getMirrorSlope());
      }
      this.updateSegmentLength=function() {// TODO: better function (like one that sets a property of this DSF)
        // console.trace("updateSegmentLength");
        let curPos=new Vec2();
        
        // let segLenLowerBound=0.001;     // TODO: arbitrary
        // let segLenUpperBound=3;
        let segLenLowerBound=0;
        let segLenUpperBound=20;
        let runningAng;
        let segLen;
        
        let edgeWord=this.getEdgeWord();
        const numIterations=70;
        for (var iterations = 0; iterations < numIterations; iterations++) {
          // let differenceWord=[];// TODO: make more efficient with a single difference word
          // for (var i = 1; i < edgeWordLength; i++) {
          //   edgeWord.push(edgeWord[i]-edgeWord[i-1]);
          // }
          // console.log(edgeWord);
          segLen=(segLenLowerBound+segLenUpperBound)/2;
          
          let runningLen=0;
          runningAng=0;
          let innerTurnAngBonus=0;
          // for (var j = 0; j < schlafliP; j++) {
          for (var i = 0; i < edgeWord.length; i++) {
            let innerTurnAng=0;
            if (i!=0) {//certain things (like getting the previous segment) will only work if this is not first segment
              innerTurnAng=TAU * (edgeWord[i]-edgeWord[i-1])/schlafliQ;//the angle between the current and previous segments // TODO: i don't fully understand why this works (why eW[i]-eW[i-1] is 1 or -1)
            }
            let innerTurnAngWithBonus=innerTurnAng-innerTurnAngBonus;
            
            // do some trigonometry (using https://en.wikipedia.org/wiki/Hyperbolic_triangle // TODO: cite better) to find unknowns in the triangle {old displacement Vector, current path segment, new displacement vector} with angles {new innerTurnAngBonus, runningAngChange, old innerTurnAngWithBonus}
            
            // TODO: make these 3 into one function? (maybe not needed, but there's a lot of copying with slight modifications)
            innerTurnAngBonus=hypSASGetAngleAtFirstSide(segLen, innerTurnAngWithBonus, runningLen);
            let newRunningLen=hypSASGetThirdEdge(runningLen, innerTurnAngWithBonus, segLen);
            let runningAngChange=hypSASGetAngleAtFirstSide(runningLen, innerTurnAngWithBonus, segLen); //how much needs to be added to the running angle. it is equal to the angle between the new and old running-displacement-vectors
            
            // console.log("Known:", "runningLen", runningLen, "innerTurnAngWithBonus", innerTurnAngWithBonus, "segLen", segLen);
            // console.log("Just calculated:", "innerTurnAngBonus", innerTurnAngBonus, "newRunningLen", newRunningLen, "runningAngChange", runningAngChange);
            
            
            runningAng+=runningAngChange;
            runningLen=newRunningLen;
            // curPos=Vec2FromAngleAndHypLength(runningAng, runningLen);
          }
          
          if (runningLen>edgeLengthHyp) {
            segLenUpperBound=segLen;
          }
          else {
            segLenLowerBound=segLen;
          }
          // console.log(p2.y, p3.y);
        }
        globalEdgeAngleOffset=runningAng;//update globalEdgeAngleOffset // TODO: done here out of convenience, maybe should be made separate
        this.segmentLength=segLen;
      }
      this.drawWithSettings=function(settings) {
        // console.trace("drawWithSettings", initialDrawingReady);
        let ctx=settings.context;
        ctx.lineWidth=1;
        ctx.strokeStyle=settings.strokeStyle;
        ctx.fillStyle=settings.fillStyle;
        
        let edgeVector=this.getEdgeVector();
        let maxDistFromCenter;
        if (settings.useDistFromCenter) {
          maxDistFromCenter=this.getMaxDistFromCenter();
        }
        // console.log(maxDistFromCenter);
        
        // let segLen=1/maxDistFromCenter;
        const segLen=this.segmentLength;
        // const segLen=(-colorChangeSteps/500%1+1)%1 *0.1;
        // const segLen=(-colorChangeSteps/50%1+1)%1 *0.2;
        // const segLen=(-colorChangeSteps/50%1+1)%1 *0.05;
        
        // const startPos=new Vec2(0.5*Math.tan(HPI-PI/schlafliP), 0.5).mult(edgeVector.len());
        // const startPos=new Vec2(-0.5*Math.cot(PI/schlafliP), 0.5).mult(edgeVector.len());// TODO: untested
        // TODO: i don't know why this works
        // set startPos - the point where the path begins drawing - as one of the vertexes of the central tile
        // scale the starting point, turning an edge length of 1 (tilingTransforms must create edges of length 1) into an edge length of edgeVector.len())
        
        // const startPos=new Vec2();
        
        // const startingAng=0;
        // let hypTranslationThatTakesTheCenterOfATileToItsVertex=new HypTransform();
        const startingAng=PI-globalEdgeAngleOffset-PI/schlafliQ;
        let hypTranslationThatTakesTheCenterOfATileToItsVertex=new HypTransform(0, centerToVertexHyp);// TODO: rename
        // const startingLen=0.0001;
        // const startingLen=0.3;
        // const startingLen=centerToVertexEuc;
        // console.log(startingLen);
        // const startPos=Vec2FromAngleAndHypLength(startingAng, startingLen);
        // const startPos=Vec2FromAngleAndHypLength(PI-globalEdgeAngleOffset-PI/schlafliQ, startingLen);
        // const startPos=Vec2FromAngleAndHypLength(0, startingLen);
        // const startPos=Vec2FromAngleAndHypLength(0, centerToVertexHyp);
        const startPos=hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2());
        
        const tilingTransformNumber=settings.useTilingTransforms ? tilingTransforms.length : 1;//how many of the tiling transforms are going to be used to repeatedly draw the tile
        
        // let edgeWord=this.getBoundaryWord();
        let edgeWord=this.getEdgeWord();
        let edgeWordLength=edgeWord.length;
        for (var j = 1; j < schlafliP; j++) {
          for (var i = 0; i < edgeWordLength; i++) {
            edgeWord.push(edgeWord[i]+j);
          }
        }
        // let differenceWord=[];// TODO: make more efficient with a single difference word
        // for (var i = 1; i < edgeWordLength; i++) {
        //   edgeWord.push(edgeWord[i]-edgeWord[i-1]);
        // }
        // console.log(edgeWord);
        
        for (var ttr = 0; ttr < tilingTransformNumber; ttr++) {// TODO: fewer things can be in this loop (like the edgeWord definition) // TODO: maybe first calculate all the points once and then loop over the transformations {and the points}
            let transf=tilingTransforms[ttr];
            //define the tiles' contact point as the beginning of the boundary
            let curPos=startPos;
          
            ctx.beginPath();
            // let curScreenPos=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(startPos)).add(settings.pos).screen();
            // let curScreenPos=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(curPos)).screen();
            // let curScreenPos=transf.applyTo(curPos).mult(globalScaling).screen();
            // let curScreenPos=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2())).screen();
            let curScreenPos=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2())).mult(globalScaling).screen();
            // console.log(curScreenPos);
            ctx.moveTo(curScreenPos.x, curScreenPos.y);//beginning to draw the path, move to the starting point
            
            // let innerTurnAngBonus=PI+0.00001;
            // let innerTurnAngBonus=0.00001;
            // let innerTurnAngBonus=startingAng;
            let innerTurnAngBonus=0;
            let runningAng=startingAng;
            let runningLen=0;
            // let lastPosTransformed=transf.applyTo(startPos);
            // let lastPosTransformed=transf.applyTo(startPos);
            let lastPosTransformed=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2())).add(new Vec2(0.0001, 0.0001));// TODO: ugh
            // console.log(lastPosTransformed);
            let curPosTransformed=new Vec2();
        
            // for (var j = 0; j < schlafliP; j++) {
              for (var i = 0; i < edgeWord.length-1; i++) {
                let innerTurnAng=0;
                if (i!=0) {//certain things (like getting the previous segment) will only work if this is not first segment
                  innerTurnAng=TAU * (edgeWord[i]-edgeWord[i-1])/schlafliQ;//the angle between the current and previous segments // TODO: i don't fully understand why this works
                  // console.log("edgeWord[i]-edgeWord[i-1]", edgeWord[i]-edgeWord[i-1]);
                }
                let innerTurnAngWithBonus=innerTurnAng-innerTurnAngBonus;
                
                // do some trigonometry (using https://en.wikipedia.org/wiki/Hyperbolic_triangle) to find unknowns in the triangle {old displacement Vector, current path segment, new displacement vector} with angles {new innerTurnAngBonus, runningAngChange, old innerTurnAngWithBonus}
                
                // TODO: make these 3 into one function? (maybe not needed, but there's a lot of copying with slight modifications)
                innerTurnAngBonus=hypSASGetAngleAtFirstSide(segLen, innerTurnAngWithBonus, runningLen);
                let newRunningLen=hypSASGetThirdEdge(runningLen, innerTurnAngWithBonus, segLen);
                let runningAngChange=hypSASGetAngleAtFirstSide(runningLen, innerTurnAngWithBonus, segLen); //how much needs to be added to the running angle. it is equal to the angle between the new and old running-displacement-vectors
                
                // console.log("Known:", "runningLen", runningLen, "innerTurnAngWithBonus", innerTurnAngWithBonus, "segLen", segLen);
                // console.log("Just calculated:", "innerTurnAngBonus", innerTurnAngBonus, "newRunningLen", newRunningLen, "runningAngChange", runningAngChange);
                
                runningAng+=runningAngChange;
                runningLen=newRunningLen;
                // console.log("Result:", "runningLen", runningLen, "runningAng", runningAng);
                curPos=Vec2FromAngleAndHypLength(runningAng, runningLen);
                // console.log(curPos);
                
                // let scaledCurPos=curPos.mult(settings.useDistFromCenter ? 1/maxDistFromCenter : 1/edgeVector.len());
                // let curScreenPos=transf.applyTo(scaledCurPos).mult(settings.DSFRelativeRadius).add(settings.pos).screen();//in tessellation // TODO: currently used one is modified from this; do i need the full version for hyperbolic drawing?
                
                // curScreenPos=transf.applyTo(scaledCurPos).add(settings.pos).screen();
                curPosTransformed=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(curPos));
                // curPosTransformed=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(curPos)).add(0.001, 0.001);
                
                // ctx.lineTo(curScreenPos.x, curScreenPos.y);
                
                // console.log(ttr, lastPosTransformed, curPosTransformed);
                // console.log(ttr, lastPosTransformed.screen(), curPosTransformed.screen());
                pathPoincareEdge(lastPosTransformed, curPosTransformed);
                
                lastPosTransformed=curPosTransformed;
              }
            // }
            
            // pathPoincareEdge(transf.applyTo(curPos).mult(globalScaling), curPosTransformed);
            // pathPoincareEdge(transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2())), curPosTransformed);
            // console.log(curPosTransformed.screen(), transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2())).screen());
            pathPoincareEdge(curPosTransformed, transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2())));
            
            // console.log(curScreenPos);
            // ctx.fillStyle="#ff09";
            // ctx.fillRect(curScreenPos.x-3, curScreenPos.y-3, 6, 6);
            // ctx.fillStyle="#9999";
            // let endScreenPos=curPos.screen();
            // ctx.fillRect(endScreenPos.x-3, endScreenPos.y-3, 6, 6);
            // ctx.fillStyle="#f119";
            // let edgeEndScreenPos=Vec2FromAngleAndHypLength(globalEdgeAngleOffset, edgeLengthHyp).screen();
            // ctx.fillRect(edgeEndScreenPos.x-3, edgeEndScreenPos.y-3, 6, 6);
            
            // ctx.closePath();
            // ctx.fillStyle="darkgreen";
            // ctx.fill("evenodd");
            ctx.stroke();
          }
      }
      this.drawToWholeScreen=function() {
        let settings=new DSFDrawingSettings();
        settings.DSFRelativeRadius=globalScaling;
        settings.useTilingTransforms=true;
        // settings.context=changingContext;
        // settings.pos=new Vec2(1, 0).mult(globalScaling);
        // settings.fillStyle="#048c";
        this.drawWithSettings(settings);
      }
      this.isEqualTo=function(d) {// TODO: this should check if they're eqivalent after rotation or mirroring (i.e. w0*w1==w1*wordRho(1, w0))
        if (this.w0.length==d.w0.length && this.w1.length==d.w1.length) {
          for (var i = 0; i < this.w0.length; i++) {
            if (this.w0[i]!=d.w0[i]) return false;
          }
          for (var i = 0; i < this.w1.length; i++) {
            if (this.w1[i]!=d.w1[i]) return false;
          }
          return true;
        }
        else {
          return false;
        }
      }
      this.turningNumber=function() {
        if (this.len()==0) {
          return 0;
        }
        let T=0;
        let word=this.getBoundaryWord();
        for (var i = 0; i < word.length; i++) {
          let prevLetter= i==0 ? word[word.length-1] : word[i-1];
          let curTurn=mod(word[i]-prevLetter, schlafliP);// (w[i]-w[i-1]) % schlafliP
          if (curTurn!=schlafliP/2) {
            if (curTurn>schlafliP/2) curTurn-=schlafliP;
            T+=curTurn;
          }
        }
        return T/schlafliP;
      }
      this.isValidInSomeNotYetClearWay=function() {// TODO:
        let edge0=this.w0.slice().concat(this.w1);
        let edge1=this.w1.slice().concat(wordRho(1, this.w0));
        // console.log("first test", arraysShallowEqual(edge0, edge0.slice().reverse()), "second", arraysShallowEqual(edge1, edge1.slice().reverse()));
        // console.log(edge1, edge1.slice().reverse());
        // TODO: is turning number needed?
        // console.log(Math.abs(this.turningNumber()));
        // if (arraysShallowEqual(edge0, edge0.slice().reverse()) && arraysShallowEqual(edge1, edge1.slice().reverse()) && Math.abs(this.turningNumber())==1) {
        if (arraysShallowEqual(edge0, edge0.slice().reverse()) && arraysShallowEqual(edge1, edge1.slice().reverse())) {
          return true;
        }
        return false;
      }
      this.isValidPolyform=function() {// TODO: would likely be useful

      }
    }
    function DSFDrawingSettings() {
      this.context=context;
      this.pos=new Vec2();
      this.DSFRelativeRadius=DSFGridScaling;// TODO: rename // TODO: different default?
      this.strokeStyle="#fff";
      this.fillStyle="#0000";
      this.useTilingTransforms=false;
      this.useDistFromCenter=false;
    }

    // var curDSF=new DSF([0,1,0,1], [2,1,2,1,0,1,0]);
    // var curDSF=new DSF([0], [1,0,1,0]);
    // var curDSF=new DSF([1,0,1,0], [1]);
    // var curDSF=new DSF([1,0,1,0,5,0,5,4,5,4], [5,0,5,0,1,0,1,2,1,2,1,0,1,0,5,0,5,4,5,4,5,0,5,0,1,0,1]);
    // var curDSF=new DSF([5,0,5,0,1,0,1,2,1,2,1,0,1,0,5,0,5,4,5,4,5,0,5,0,1,0,1], [2,1,2,1,0,1,0,5,0,5]);
    // var curDSF=new DSF([0], []);
    
    // var curDSF=new DSF([0,0,2,3], []);
    // var curDSF=new DSF([0,0,2], []);// TODO: this is still broken (and i don't expect that i'll fix it)
    // var curDSF=new DSF([0,1,0,1,2,1], []);

    function logCurDSFInfo() {
      console.log("%c"+curDSF.w0+" and "+curDSF.w1, "font-size: 180%; color: #9f6; padding-top:2%; padding-bottom: 2%");
      console.log(wordRho(-1, curDSF.w0), wordRho(-1, curDSF.w1), curDSF.w0, curDSF.w1, wordRho(1, curDSF.w0), wordRho(1, curDSF.w1));
      console.log("%c                                                   ", "display: inline-block; border: 2px solid lightgray; font-size:1px");
      // console.log("%cha", "border-radius:10px");
      let uv0=curDSF.getU0V0();
      console.log("u0", uv0.u, "v0", uv0.v);
      let uv1=curDSF.getU1V1();
      console.log("u1", uv1.u, "v1", uv1.v);
      console.log("%c                                                   ", "display: inline-block; border: 2px solid lightgray; font-size:1px");
    }

    var curDSF=new DSF([], []);
    // var curDSF=new DSF([], [0]);
    // curDSF=curDSF.extend0();
    // var curDSF=new DSF([0], []);
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.swap1();// TODO: generation seems broken // TODO: why did i write that???
    // curDSF=curDSF.swap0();
    // curDSF=curDSF.extend0();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.trimIfPossible();
    // logCurDSFInfo();
    // console.log("%cresult", "font-size:200%; padding:1%");
    // console.log(curDSF.w0, curDSF.w1);
    // console.log("Result: |w0|="+curDSF.w0.length+", |w1|="+curDSF.w1.length);
    
    // dsfOperationsInput.value="";
    dsfOperationsInput.value="e1";
    // dsfOperationsInput.value="e1e0s0";
    updateCurDSFOperations();

    var resultingDSFArray=[];
    function generateDSFGrid() {// TODO: hyperbolic tile support
      const gridHeight=4;
      const gridWidth=Math.floor(gridHeight*canvas.width/height);
      const numToGenerate=gridHeight*gridWidth;
      // const UOperatorNames=["extend0", "extend1", "swap0", "swap1"];
      let T=[];
      resultingDSFArray=[];
      let Q=[curDSF];//words on which no operations have been done
      while (resultingDSFArray.length<numToGenerate) {//generate into T until its length reaches numToGenerate
        if (Q.length==0) {
          console.warn("Q ran out of elements (should be impossible in standard conditions)!");
          break;
        }
        // let S=Q.pop();
        let S=Q.shift();

        let SIsNotYetInT=true;
        for (var ti = 0; ti < T.length; ti++) {//check if S is in T
          if (S.isEqualTo(T[ti])) SIsNotYetInT=false;
        }
        if (SIsNotYetInT) {
          T.push(S);
          // console.log(S.isValidInSomeNotYetClearWay());// TODO: always true, even when self-crossing
          if (S.isValidInSomeNotYetClearWay()) resultingDSFArray.push(S);
        }

        let U=[S.extend0(), S.extend1(), S.swap0(), S.swap1()];
        // console.log(U);
        // console.log(S.extend1());
        for (var ui = 0; ui < U.length; ui++) {
          let alreadyGenerated=false;

          for (var qi = 0; qi < Q.length; qi++) {//check if U[ui] is in Q
            if (Q[qi].isEqualTo(U[ui])) alreadyGenerated=true;
          }
          for (var ti = 0; ti < T.length; ti++) {//check if U[ui] is in T
            if (T[ti].isEqualTo(U[ui])) alreadyGenerated=true;
          }
          // console.log("!alreadyGenerated", !alreadyGenerated);
          if (!alreadyGenerated) {
            // console.log("U[ui].length>S.length", U[ui].length>S.length);
            // console.log(U[ui], S);
            if (U[ui].len()>S.len()) {
              Q.push(U[ui]);
            }
          }
        }
      }
      console.log("resultingDSFArray", resultingDSFArray);
      let settings=new DSFDrawingSettings();
      settings.fillStyle="#8a1";
      settings.DSFRelativeRadius=DSFGridScaling/gridHeight;
      settings.useDistFromCenter=true;

      for (var i = 0; i < gridHeight; i++) {
        for (var j = 0; j < gridWidth; j++) {
          let wordIndex=i*gridWidth+j;
          // if (wordIndex>=1) {
          if (wordIndex>=resultingDSFArray.length) {//ran out of tiles! (normally shouldn't be possible)
            return undefined;
          }
          // settings.pos=new Vec2((j*2-gridWidth+1)/gridHeight, (i*2-gridHeight+1)/gridHeight);// TODO: why was this mirrored vertically? something might be messed up elsewhere... (or maybe i want positive y to be downwards?)
          settings.pos=new Vec2((j*2-gridWidth+1)/gridHeight, -(i*2-gridHeight+1)/gridHeight);
          // console.log(settings.pos);
          resultingDSFArray[wordIndex].drawWithSettings(settings);

          ////debug points (centers of tiles)
          // context.fillStyle="#f00";
          // let curPos=new Vec2((j*2-gridWidth+1)/gridHeight, (i*2-gridHeight+1)/gridHeight).screen();
          // context.fillRect(curPos.x-1, curPos.y-1, 2, 2);
        }
      }
    }
    
    
    ;//COLORS
      function Color(r=255, g=0, b=255, a=1) {
        this.r=r;
        this.g=g;
        this.b=b;
        this.a=a;
        this.copy=function() {
          return new Color(this.r, this.g, this.b, this.a);
        }
        this.each=function(f) {
          return new Color(f(this.r), f(this.g), f(this.b));
        }
        this.modify=function(amp) {
          return this.each(function(n) {
            var x=n+rand0(amp);
            if (x>255) {
              return 255;
            }
            else if (x<0) {
              return 0;
            }
            else {
              return x;
            }
          });
        }
        this.add=function(v) {
          return new Color(this.r+v.r, this.g+v.g, this.b+v.b);
        }
        this.lighten=function(v) {
          return new Color(v*(256-this.r)+this.r, v*(256-this.g)+this.g, v*(256-this.b)+this.b);
        }
        this.sub=function(v) {
          return new Color(this.r-v.r, this.g-v.g, this.b-v.b);
        }
        this.mult=function(v) {
          return new Color(this.r*v, this.g*v, this.b*v);
        }
        this.multColor=function(c) {
          return new Color(this.r*c.r/256, this.g*c.g/256, this.b*c.b/256);
        }
        this.rgb=function() {
          return "rgb("+this.r+","+this.g+","+this.b+")";
        }
        this.square=function() {
          return new Color(this.r**2, this.g**2, this.b**2, this.a);
        }
        this.sqrt=function() {
          return new Color(Math.sqrt(this.r), Math.sqrt(this.g), Math.sqrt(this.b), this.a);
        }
        this.grayen=function(amp) {
          return this.each(function(n){
            return n*(1-amp)+128*amp;
          });
        }
      }
      function ColorFromHSL(h=5/6, s=1, l=0.5, a=1) {
        // TODO: this is dumb (alsoneed a reference)
        h=(h%1+1)%1;
        let c = (1 - Math.abs(2 * l - 1)) * s,
            x = c * (1 - Math.abs((h*6) % 2 - 1)),
            m = l - c/2,
            r = 0,
            g = 0,
            b = 0;

        if (0 <= h && h < 1/6) {
          r = c; g = x; b = 0;
        }
        else if (1/6 <= h && h < 1/3) {
          r = x; g = c; b = 0;
        } else if (1/3 <= h && h < 1/2) {
          r = 0; g = c; b = x;
        } else if (1/2 <= h && h < 2/3) {
          r = 0; g = x; b = c;
        } else if (2/3 <= h && h < 5/6) {
          r = x; g = 0; b = c;
        } else if (5/6 <= h && h < 1) {
          r = c; g = 0; b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);

        return new Color(r, g, b, a);
      }
      function Gradient(v) {
        this.colors=[];
        this.values=[];
        for (var i = 0; i < v.length; i+=2) {
          this.colors[i/2]=v[i];
          this.values[i/2]=v[i+1];
        }
        this.get=function(x) {
          for (var i = 0; i < this.values.length; i++) {
            if (this.values[i]>x) {
              if (i==0) {
                return this.colors[0].copy();
              }
              else {
                // return this.colors[i].sub(this.colors[i-1]).mult((x-this.values[i-1])/(this.values[i]-this.values[i-1])).add(this.colors[i-1]); // simple, ugly mixing
                return this.colors[i].square().sub(this.colors[i-1].square()).mult((x-this.values[i-1])/(this.values[i]-this.values[i-1])).add(this.colors[i-1].square()).sqrt(); // complicated, expesive, prettier mixing
              }
            }
          }
          return this.colors[this.colors.length-1].copy();
        }
      }
      var colors={//list of all predefined colors
        // mist: new Color(110, 130, 210),
        // sky: new Color(50, 150, 210),
        // darkBrown: new Color(40, 17, 2),
        // lightBrown: new Color(200, 160, 60),
        // sand: new Color(200, 170, 120),

        white: new Color(255, 255, 255),
        black: new Color(0, 0, 0),
        red: new Color(255, 0, 0),
        green: new Color(0, 255, 0),
        blue: new Color(0, 0, 255),
        yellow: new Color(255, 255, 0),
        magenta: new Color(255, 0, 255),
        cyan: new Color(0, 255, 255),

        darkRed: new Color(127, 0, 0),
        darkGreen: new Color(0, 127, 0),
        darkBlue: new Color(0, 0, 127),
        darkYellow: new Color(127, 127, 0),
        darkMagenta: new Color(127, 0, 127),
        darkCyan: new Color(0, 127, 127),
        // veryDarkRed: new Color(63, 0, 0),
        // veryDarkGreen: new Color(0, 63, 0),
        // veryDarkBlue: new Color(0, 0, 63),
        // veryDarkYellow: new Color(63, 63, 0),
        // veryDarkMagenta: new Color(63, 0, 63),
        // veryDarkCyan: new Color(0, 63, 63),

        orange: new Color(255, 127, 0),
        gray: new Color(127, 127, 127),
        darkGray: new Color(63, 63, 63),
        darkGray: new Color(63, 63, 63),
        slate: new Color(50, 67, 127)
        // brown: new Color(64, 32, 0)
      }
      var gradients={// TODO: not really used much
        leafy: new Gradient([colors.veryDarkGreen, 0, colors.green, 0.5, colors.yellow, 1]),
        rainbow: new Gradient([colors.black, 0, colors.red, 0.1, colors.yellow, 0.26, colors.green, 0.42, colors.cyan, 0.58, colors.blue, 0.74, colors.magenta, 0.9, colors.white, 1]),
        natural: new Gradient([colors.black, 0, colors.green, 0.6, colors.yellow, 0.8, colors.white, 0.9, colors.red, 1]),
        tech: new Gradient([colors.black, 0, colors.darkBlue, 0.3, colors.cyan, 0.6, colors.white, 1]),
        flame: new Gradient([colors.black, 0, colors.darkBlue, 0.1, colors.white, 0.24, colors.yellow, 0.38, colors.red, 0.7, colors.black, 1]),
        middleBand: new Gradient([colors.black, 0.4, colors.white, 0.401, colors.white, 0.599, colors.black, 0.6]),
        middleNarrowBand: new Gradient([colors.white, 0.47, colors.black, 0.472, colors.black, 0.528, colors.white, 0.53]),
        blendingTest: new Gradient([colors.green, 0, colors.red, 1])
      }
      var useGradient=gradients.tech;

      // var takeColors=[[255,255,0],
      //   [213, 94, 0],
      //   [0, 114, 178],
      //   [230, 220, 60],
      //   [204, 121, 167],
      //   [0, 158, 115],
      //   [86, 180, 233],
      //   [230, 159, 0]
      // ]
      // for (var i = 0; i < takeColors.length; i++) {
      //   var curColor=new Color(takeColors[i][0], takeColors[i][1], takeColors[i][2]);
      //   var curFaceColor=curColor.rgb();
      //   curFaceColor=curFaceColor.substring(0, curFaceColor.length-1)+",30%)";
      //   takeColors[i]={
      //     vertex: curColor.rgb(),
      //     edge: curColor.rgb(),
      //     face: curFaceColor
      //   }
      // }

      var drawColors=[];
      for (const col in colors) {//initialize drawColors with all predefined colors
        drawColors.push(colors[col]);
      }
      for (var i = 0; i < drawColors.length; i++) {//add color select elements
        document.getElementById("color-select-dropdown").innerHTML+="<div class='color-select-option' style='background-color: "+drawColors[i].rgb()+"' onclick='selectFillColor(drawColors["+i+"])'> </div>";
      }
      
      var boundaryCircleColor="hsla(0, 0%, 100%, 0.7)";
      var hypPolyEdgeColor="rgb(110, 110, 110)";
      var hypPolyVertDefaultColor="rgb(220, 220, 220)";
    
      var BGColor=new Color(0, 0, 0);
      var fillColor=new Color(255, 255, 255);
      var fillColorWithErase=fillColor;//temporary color (same as fillColor except when erasing, then it's the background color)
    
    function Vec2(x=0, y=0) {
      this.x=x;
      this.y=y;
      this.copy=function() {
        return new Vec2(this.x, this.y);
      }
      this.add=function(v1, v2) {// FIXME: doesn't always work with both values
        if (v2!=undefined) {
          return new Vec2(this.x+v1, this.y+v2);
        }
        return new Vec2(this.x+v1.x, this.y+v1.y);
      }
      this.sub=function(v) {
        return new Vec2(this.x-v.x, this.y-v.y);
      }
      this.mult=function(n) {
        return new Vec2(this.x*n, this.y*n);
      }
      this.div=function(n) {
        return new Vec2(this.x/n, this.y/n);
      }
      this.dot=function(v) {
        return v.x*this.x + v.y*this.y;
      }
      this.iHatLanding=function(v) {
        return new Vec2(v.x*this.x-v.y*this.y, v.x*this.y+v.y*this.x);
      }
      this.len=function() {
        return Math.sqrt(this.x**2+this.y**2);
      }
      this.sqLen=function() {
        return this.x**2+this.y**2;
      }
      this.dist=function(v) {
        return Math.sqrt((this.x-v.x)**2+(this.y-v.y)**2);
      }
      this.sqDist=function(v) {
        return (this.x-v.x)**2+(this.y-v.y)**2;
      }
      this.unit=function() {
        var len=Math.sqrt(this.x**2+this.y**2);
        return new Vec2(this.x/len, this.y/len);
      }
      this.ang=function() {//angle to x axis in radians
        return Math.atan2(this.y, this.x);
      }
      this.taxi=function() {//taxicab distance
        return this.x+this.y;
      }
      this.screen=function() {//coordinates for drawing
        // return new Vec2(this.x-0.5*this.y, this.y*HALFROOT3);
        return new Vec2(this.x*height/2+canvas.width/2, height/2-this.y*height/2);// TODO: not quite to screen height, also optimize?
        // return new Vec2(0.5*(this.x*height+canvas.width), ((this.y+1)*0.5)*height);// TODO: is this one better?
      }
      this.unscreen=function() {//coordinates for mouse interaction
        return new Vec2((this.x-canvas.width/2)*2/height, (height/2-this.y)*2/height);// TODO:
      }
      this.rotate=function(a) {
        return new Vec2(this.x*Math.cos(a)-this.y*Math.sin(a), this.x*Math.sin(a)+this.y*Math.cos(a));
      }
    }
    function Vec2FromAngleAndLength(ang, len=1) {
      return new Vec2(len*Math.cos(ang), len*Math.sin(ang));
    }
    function Vec2FromAngleAndHypLength(ang, len=1) {
      len=hypToEucDist(len);
      return new Vec2(len*Math.cos(ang), len*Math.sin(ang));
    }
    
    // //Affine2 definition, not used anymore
    // function Affine2(iHatX=1, iHatY=0, jHatX=0, jHatY=1, shiftX=0, shiftY=0) {//class for a 2D affine transformation
    //   this.iHatX=iHatX;
    //   this.iHatY=iHatY;
    //   this.jHatX=jHatX;
    //   this.jHatY=jHatY;
    //   this.shiftX=shiftX;
    //   this.shiftY=shiftY;
    //   this.getCopy=function() {// TODO: untested (unnecessary?)
    //     return new Affine2(this.iHatX, this.iHatY, this.jHatX, this.jHatY, this.shiftX, this.shiftY);
    //   }
    //   this.getIHat=function(){return new Vec2(this.iHatX, this.iHatY);};
    //   this.getJHat=function(){return new Vec2(this.jHatX, this.jHatY);};
    //   this.getShift=function(){return new Vec2(this.shiftX, this.shiftY);};
    //   this.applyTo=function(v) {
    //     return new Vec2(v.x*this.iHatX+v.y*this.jHatX+this.shiftX, v.x*this.iHatY+v.y*this.jHatY+this.shiftY);
    //   }
    //   this.scaleShiftBy=function(s) {//multiply the shifting vector by s
    //     let copy=this.getCopy();
    //     copy.shiftX*=s;
    //     copy.shiftY*=s;
    //     return copy;
    //   }
    //   this.scaleTransformBy=function(s) {//multiply the linear transformation matrix by s
    //     let copy=this.getCopy();
    //     copy.iHatX*=s;
    //     copy.iHatY*=s;
    //     copy.jHatX*=s;
    //     copy.jHatY*=s;
    //     return copy;
    //   }
    // }
    // function Affine2FromShift(v) {
    //   return new Affine2(1, 0, 0, 1, v.x, v.y);
    // }
    // function Affine2FromAngle(a) {
    //   return new Affine2(Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a), 0, 0);
    // }
    // function Affine2FromAngleAndShift(a, v) {
    //   return new Affine2(Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a), v.x, v.y);
    // }
    
    function HypTransform(shiftAng=0, shiftDist=0, rotateAng=0) {//hyperbolic isometry, with rotation by rotateAng and then a translation that moves the origin to the polar coordinates {shiftAng, shiftDist}
      this.shiftDist=shiftDist;
      this.shiftAng=shiftAng;
      this.rotateAng=rotateAng;
      this.getCopy=function() {
        return new HypTransform(this.shiftAng, this.shiftDist, this.rotateAng);
      }
      this.applyTo=function(v) {
        let res=v.rotate(this.rotateAng-this.shiftAng);
        res=this.applyTranslationTo(res);
        res=res.rotate(this.shiftAng);
        return res;
      }
      this.applyTranslationTo=function(v) {
        if (isEuclidean) {
          return new Vec2(v.x+this.shiftDist, v.y);
        }
        else if (curvature==-1) {
          let ex=Math.exp(this.shiftDist)
          //formula adapted from the final equation in the answer by MvG (https://math.stackexchange.com/users/35416/mvg), Rigid body motion on the Poincare disc model of the hyperbolic plane, URL (version: 2013-02-19): https://math.stackexchange.com/q/308492
          return new Vec2(
            (ex*v.x+v.x+ex-1) * (ex*v.x-v.x+ex+1) - (ex*v.y+v.y) * (v.y-ex*v.y),
            4*ex*v.y
          ).div((ex*v.x-v.x+ex+1)**2 + (ex*v.y-v.y)**2);
          // return new Vec2(// TODO: optimize? (same as in applyTo)
          //   (ex*v.x+v.x+ex-1) * (ex*v.x-v.x+ex+1) - (ex*v.y+v.y) * (v.y-ex*v.y),
          //   4*ex*v.y
          // ).div((ex*v.x-v.x+ex+1)**2 + (ex*v.y-v.y)**2);
        }
        else {
          //input point (v.x, v.y) in stereographic projection, calculate point (sphX, sphY, sphZ) on sphere
          let sphX=2*v.x/(1+v.x**2+v.y**2);
          let sphY=2*v.y/(1+v.x**2+v.y**2);
          let sphZ=(-1+v.x**2+v.y**2)/(1+v.x**2+v.y**2);
          
          //rotate sphX and sphZ in the xz plane
          let sphXRot=sphX*Math.cos(this.shiftDist)-sphZ*Math.sin(this.shiftDist);
          let sphZRot=sphX*Math.sin(this.shiftDist)+sphZ*Math.cos(this.shiftDist);
          
          //stereographically project the point back
          return new Vec2(sphXRot/(1-sphZRot), sphY/(1-sphZRot));
        }
      }
      
      // TODO: unimplemented. are these two functions needed?
      this.scaleShiftBy=function(s) {//multiply the shifting vector by s
        let copy=this.getCopy();
        copy.shiftDist*=s;
        return copy;
      }
      this.scaleTransformBy=function(s) {//multiply the linear transformation matrix by s
        let copy=this.getCopy();
        // copy.iHatX*=s;
        // copy.iHatY*=s;
        // copy.jHatX*=s;
        // copy.jHatY*=s;
        return copy;
      }
    }
    function hypSASGetAngleAtFirstSide(a, C, b) {// In a hyperbolic triangle, given two edges a, b and the angle between them, calculate the angle opposite b // TODO: rename?
      // if (mod(C, TAU)==0) {
      if (Math.abs(mod(C, TAU))<=0.0000001) {// TODO: use an epsilon (?)
        if (a<b) {
          return PI;
        }
        else if (b<a) {
          return 0;
        }
        else {
          return HPI;
        }
      }
      if (isEuclidean) {
        let c=hypSASGetThirdEdge(a, C, b);
        if (a<b) {
          let A=Math.asin(a*Math.sin(C)/c);
          return PI-C-A;
        }
        else {
          let B=Math.asin(b*Math.sin(C)/c);
          return B;
        }
      }
      else if (curvature==-1) {
        //hyperbolic four-parts formula, adapted from https://en.wikipedia.org/wiki/Hyperbolic_triangle, retrieved 16.07.2021
        // return Math.acot((Math.sinh(a)*Math.coth(b)-Math.cos(C)*Math.cosh(a))/Math.sin(C));//direct copy, but these functions are not defined
        // return Math.atan(Math.sin(C)/(Math.sinh(a)/Math.tanh(b)-Math.cos(C)*Math.cosh(a)));//modified to work, but this still breaks in some edge cases
        let res=Math.atan(Math.sin(C)/(Math.sinh(a)/Math.tanh(b)-Math.cos(C)*Math.cosh(a)));
        if (res<0 ^ mod(C, TAU)>PI) {// TODO: i got to this solution while messing around on desmos, some kind of proof/explanation would be fitting
          res+=PI;
        }
        return res;
      }
      else {
        //hyperbolic four-parts formula, adapted from https://en.wikipedia.org/wiki/Spherical_trigonometry#Cotangent_four-part_formulae (CT6), retrieved 16.07.2021
        // let res=Math.acot((Math.sin(a)*Math.cot(b)-Math.cos(C)*Math.cos(a))/Math.sin(C));//direct copy
        let res=1/Math.atan((Math.sin(a)/Math.tan(b)-Math.cos(C)*Math.cos(a))/Math.sin(C));
        // if (res<0 ^ mod(C, TAU)>PI) {// TODO: i got to this solution while messing around on desmos, some kind of proof/explanation would be fitting
        //   res+=PI;
        // }
        return res;
      }
    }
    function hypSASGetThirdEdge(a, C, b) {// In a hyperbolic triangle, given two edges and the angle between them, calculate the third edge // TODO: rename?
      if (isEuclidean) {
        let res=a*a+b*b-2*a*b*Math.cos(C);//law of cosines
        return Math.sqrt(res);
        // return res>=0 ? Math.sqrt(res) : 0;// TODO: will i need this?
      }
      else if (curvature==-1) {
        //formula taken from https://en.wikipedia.org/wiki/Hyperbolic_triangle on 16.07.2021
        let res=Math.cosh(a)*Math.cosh(b)-Math.sinh(a)*Math.sinh(b)*Math.cos(C);
        return res>=1 ? Math.acosh(res) : 0;// TODO: kinda janky but i probably can't avoid it
      }
      else {
        //formula taken from "Spherical Trigonometry: For the Use of Colleges and Schools by I. Todhunter", retrieved 28.07.2021 from https://www.gutenberg.org/ebooks/19770
        return Math.acos( Math.cos(a)*Math.cos(b) + Math.sin(a)*Math.sin(b)*Math.cos(C) );
      }
    }
    function hypToEucDist(rho) {// TODO: rename many functions with hyp
      if (isEuclidean) {
        return rho;
      }
      else if (curvature==-1) {
        //formula from "Poincare’s Disk Model for Hyperbolic Geometry" section 9.2.2 retrieved from https://www.ms.uky.edu/~droyster/courses/spring08/math6118/Classnotes/Chapter09.pdf on 16.07.2021
        return Math.tanh(rho/2);
      }
      else {
        //formula adapted from https://en.wikipedia.org/wiki/Stereographic_map_projection retrieved 28.07.2021
        return 2*Math.tan(HPI-rho/2);
      }
    }
    function eucToHypDist(r) {
      if (isEuclidean) {
        return r;
      }
      else if (curvature==-1) {
        //formula from "Poincare’s Disk Model for Hyperbolic Geometry" section 9.2.2 retrieved from https://www.ms.uky.edu/~droyster/courses/spring08/math6118/Classnotes/Chapter09.pdf on 16.07.2021
        return 2*Math.atanh(r);
      }
      else {
        //formula adapted from https://en.wikipedia.org/wiki/Stereographic_map_projection retrieved 28.07.2021
        return 2*(HPI-Math.atan(r/2));
      }
    }
    
    function getGeodesicCircleCenter(p1, p2) {
      let p1SqLen=p1.sqLen();
      let p2SqLen=p2.sqLen();
      let useP1Prime=p1SqLen>p2SqLen;//if p2 is closer to the center, use p1 prime (inverted across unit circle) as p3
      let p3Scaling=1/(useP1Prime ? p1SqLen : p2SqLen);
      let p3=(useP1Prime ? p1 : p2).mult(p3Scaling);
            
      //algorithm adapted from "Equation of circle when three points on the circle are given" https://www.geeksforgeeks.org/equation-of-circle-when-three-points-on-the-circle-are-given/ (retrieved 26.07.2021)
      
      let x12=p1.x - p2.x;
      let x13=p1.x - p3.x;
      
      let y12=p1.y - p2.y;
      let y13=p1.y - p3.y;
            
      // p1.x^2 - p3.x^2
      let sx13=Math.pow(p1.x, 2) - Math.pow(p3.x, 2);
      
      // p1.y^2 - p3.y^2
      let sy13=Math.pow(p1.y, 2) - Math.pow(p3.y, 2);
      
      let sx21=Math.pow(p2.x, 2) - Math.pow(p1.x, 2);
      let sy21=Math.pow(p2.y, 2) - Math.pow(p1.y, 2);
      
      let f=(sx13 * x12
           + sy13 * x12
           + sx21 * x13
           + sy21 * x13)
           / (2 * (y13 * x12 - y12 * x13));
      let g=(sx13 * y12
           + sy13 * y12
           + sx21 * y13
           + sy21 * y13)
           / (2 * (x13 * y12 - x12 * y13));
      
      return new Vec2(g, f);
    }

    function Polygon() {// TODO: classes with push, not weird index saving
      this.numNext=0;
      this.next=[];
      this.numVerts=0;
      this.verts=[];
      this.layer=0;
      // this.centerPos=new Vec2();
      this.centerAngFromXAxis=0;
      this.centerToOriginHyp=0;
      this.vertexOffsetAngle=0;//angle by which to rotate the polygon so that one of its vertexes would be horizontal relative to its center // TODO: i don't know what that means in the hyperbolic plane
      this.addNext=function (n) {
        this.next[this.numNext]=n;
        this.numNext++;
      }
      this.addVert=function (v) {
        this.verts[this.numVerts]=v;
        this.numVerts++;
      }
    };
    function Vert() {
      this.numNext=0;
      this.next=[];
      this.numPolys=0;
      this.polys=[];
      this.pos=new Vec2();
      this.drawPos=new Vec2();
      this.radius=0;
      this.addNext=function(n) {
        this.next[this.numNext]=n;
        this.numNext++;
      }
      this.addPoly=function(p) {
        this.polys[this.numPolys]=p;
        this.numPolys++;
      }
      this.setPos=function(v) {
        this.pos=v.copy();
        this.magnit=this.pos.len();

        // this.drawPos=v.copy();
        // this.drawPos=v.mult(v.len());
        // this.radius=0.13*(1-v.sqLen());
        // this.radius=0.08*(1-this.drawPos.sqLen());
        // this.drawPos=v.square();
        // this.drawPos=new Vec2(v.x, v.y);

        // let y=(Math.cosh(edgeLengthHyp*hypPolyVertRadius)-1)/2;
        // // isEuclidean ? 10 :
        // let fracBottom=1-y*this.magnit**2+y;
        // this.radius=isEuclidean ? edgeLengthHyp*hypPolyVertRadius : (1-this.magnit*this.magnit)*Math.sqrt(y*(y+1))/fracBottom;
        // // let drawCenterDist=this.magnit/fracBottom;
        // this.drawPos=this.pos.mult(1/fracBottom);

        let distortPos=distortion(this.pos);
        // TODO: where does this come from? what does this do? (i think it' s something from my notes)
        let y=(Math.cosh(edgeLengthHyp*hypPolyVertRadius)-1)/2;
        let fracBottom=1-y*this.magnit**2+y;
        this.radius=isEuclidean ? edgeLengthHyp*hypPolyVertRadius : (1-this.magnit*this.magnit)*Math.sqrt(y*(y+1))/fracBottom;
        // this.radius=0.01;
        // let drawCenterDist=this.magnit/fracBottom;
        this.drawPos=distortPos.mult(1/fracBottom);
      }
      this.draw=function() {
        let screenPos=this.drawPos.screen();

        // context.beginPath();//clear circle (may cause pixel-wide dark areas around circles)
        //   context.arc(screenPos.x, screenPos.y, this.radius*height/2, 0, TAU);
        //   context.fillStyle=BGColor.rgb();
        //   context.fill();

        context.beginPath();
        context.arc(screenPos.x, screenPos.y, this.radius*height/2, 0, TAU);
        context.fillStyle=hypPolyVertDefaultColor;
        context.fill();
      }
    };

    function smootherStep(x) {
      return x * x * x * (x * (x * 6 - 15) + 10);
    }
    function getSmoothWeightedAverage(x, v1=0, v2=1) {//lerp, but with smootherstep
      return x * x * x * (x * (x * 6 - 15) + 10)*(v2-v1)+v1;
    }
    function getWeightedSquareAverage(x, y, v1, v2, v3, v4) {//smooth interpolation
      return getSmoothWeightedAverage(y, getSmoothWeightedAverage(x, v1, v2), getSmoothWeightedAverage(x, v3, v4));
    }
    function getNoise(i, j, seed=0) {//get perlin noise at (i, j)
      var fi=Math.floor(i);
      var fj=Math.floor(j);
      var reli=i-fi;
      var relj=j-fj;
      function getCurrentDot(iOff, jOff) {
        var ang=((fi+iOff)*2+((fj+jOff+seed)*(seed+1))**2)**2;
        // var ang=((fi+iOff)+(fj+jOff)*2)**2;
        return Math.cos(ang)*(reli-iOff)+Math.sin(ang)*(relj-jOff);
      }
      return getWeightedSquareAverage(reli, relj, getCurrentDot(0, 0), getCurrentDot(1, 0), getCurrentDot(0, 1), getCurrentDot(1, 1))*0.8591+0.5;
    }

    function drawSquare(pos, w=4) {
      pos=pos.screen();
      context.fillRect(pos.x-w/2, pos.y-w/2, w, w);
    }
    function drawLine(p1, p2) {
      p1=p1.screen();
      p2=p2.screen();
      context.beginPath();
      context.moveTo(p1.x, p1.y);
      context.lineTo(p2.x, p2.y);
      context.stroke();
    }
    function drawDisk(x, y, r=4, ctx=context) {
      ctx.beginPath();
      let screenPos=new Vec2(x, y).screen();
      ctx.moveTo(screenPos.x, screenPos.y);
      ctx.arc(screenPos.x, screenPos.y, r/2+0.5, 0, TAU);
      ctx.fill();
    }

    function pathPoincareEdge(v1, v2, ctx=context) {//add one edge's (from v1 to v2) arc-shaped path to context
      // if (true) {//arc edges
        // if (!isEuclidean) {// TODO: getGeodesicCircleCenter function
        //   var circleCenter=getGeodesicCircleCenter(v1, v2);
        //   var newR=(circleCenter.sub(v1)).len();
        // }
        // if (isEuclidean || newR>=10000 || Number.isNaN(newR)) {// TODO: there has to be a better way to avoid huge radiuses (like homogenous coordinates)
        // // if (newR>=10000 || Number.isNaN(newR)) {// TODO: removing isEuclidean conditions seems to successfully draw euclidean shapes in the poincare disk, if that makes sense. maybe it'll cause problems down the line!
        //   // var v1Screen=v1.mult(globalScaling).screen();
        //   // ctx.moveTo(v1Screen.x, v1Screen.y);
        //   var v2Screen=v2.mult(globalScaling).screen();
        //   ctx.lineTo(v2Screen.x, v2Screen.y);
        // }
        // else {
        //   // console.log(newR);
        //   var circleCenterScreen=circleCenter.mult(globalScaling).screen();
        //   var ang1=-v1.sub(circleCenter).ang();
        //   var ang2=-v2.sub(circleCenter).ang();
        //   var widd=(ang1-ang2+TAU)%TAU<=PI;
        //   ctx.arc(circleCenterScreen.x, circleCenterScreen.y, newR*globalScaling*height/2, ang1, ang2, widd);
        // }
      // }
      // else {//straight edges
        // drawLine(v1, v2);//straight lines, alternative to arcs
        let v1Scaled=v1.mult(globalScaling);
        let v2Scaled=v2.mult(globalScaling);
        drawLine(v1Scaled, v2Scaled);//straight lines, alternative to arcs
      // }
    }
    function pathPoincarePoly(vertArr) {//add one polygon's (as an array of indexes in V[]) path to context
      var avgVertPos=new Vec2();
      context.beginPath();
      let firstVertScreen=V[vertArr[0]].pos.screen();
      context.moveTo(firstVertScreen.x, firstVertScreen.y);
      for (var j=0; j<vertArr.length; j++) {//all edges
        var v1=V[vertArr[j]].pos;
        var v2=V[vertArr[(j+1)%vertArr.length]].pos;
        // console.log(j, v1, v2);
        pathPoincareEdge(v1, v2);
        avgVertPos=avgVertPos.add(v1);
      }
      // context.closePath();
      avgVertPos=avgVertPos.div(schlafliP);
      return {
        "avgVertPos": avgVertPos
      }
    }
    function drawGridPoly(vertArr) {//draw a polygon which is part of the hyperbolic grid
      var pathData=pathPoincarePoly(vertArr);
      // var avgVertPos=pathData;
      // var color=new Color(randRange(30, 256), randRange(30, 256), randRange(30, 256));
      // var color=useGradient.get(rand());
      var color=useGradient.get(rand()).grayen(0.2).modify(50);
      context.lineWidth=isEuclidean
        ? 0.025*height/2
        : hypPolyEdgeWidth*(1-pathData.avgVertPos.sqLen())*height/2;
      // context.strokeStyle="rgb(0, 0, 0)";
      // context.strokeStyle="rgb(220, 220, 220)";
      context.strokeStyle=hypPolyEdgeColor;
      // context.lineWidth=1;
      // context.strokeStyle=color.rgb();
      context.fillStyle=color.rgb();
      // context.fill();
      context.stroke();
    }
    function drawAllVerts() {//draw circles on vertexes of the hyperbolic grid
      for (var i=0; i<numVerts; i++) {//all polygons
        V[i].draw();
      }
    }
    
    
    var tilingTransforms=[];
    var inTileTransforms=[];
    var mirrorM; // m of the mirror line y=mx

    function setInTileTransforms() {//define the linear transformations used to make the central tile (like order 6 rotational and mirror symmetries (AKA D6) to make a snowflake)
      // if (!initialDrawingReady) return;
      inTileTransforms=[];
      let s=schlafliP;
      for (var i = 0; i < s; i++) {
        var ang=i*TAU/s;
        inTileTransforms.push([Math.cos(ang), Math.sin(ang), -Math.sin(ang), Math.cos(ang)]);
      }
      if (useMirrors) {
        let mirrorMult=1/(1+mirrorM**2);
        let mirrorMatrix=[
          mirrorMult*(1-mirrorM**2),
          mirrorMult*(mirrorM*2),
          mirrorMult*(mirrorM*2),
          mirrorMult*(mirrorM**2-1)
        ]
        for (var i = 0; i < s; i++) {
          inTileTransforms.push([
            inTileTransforms[i][0]*mirrorMatrix[0]+inTileTransforms[i][1]*mirrorMatrix[2],
            inTileTransforms[i][0]*mirrorMatrix[1]+inTileTransforms[i][1]*mirrorMatrix[3],
            inTileTransforms[i][2]*mirrorMatrix[0]+inTileTransforms[i][3]*mirrorMatrix[2],
            inTileTransforms[i][2]*mirrorMatrix[1]+inTileTransforms[i][3]*mirrorMatrix[3]
          ]);
        }
      }
    }
    function updateMirrorAngle(slope) {//set mirrorM using the parameter or the current mirror angle input, setInTileTransforms() and clearAll()
      // console.trace(slope, typeof(slope));
      if (typeof(slope)=="undefined") {
        // console.log("a");
        mirrorM=mirrorAngleInputOptionsArr[curMirrorAngleInput][1](document.getElementById("mirror-angle-number-input-"+curMirrorAngleInput).value);
      }
      else {
        // console.log("b");
        mirrorM=slope;
      }

      // TODO: other schlafliP values should also be supported
      if (schlafliP==6) {//make mirrorM between 0 and ROOT3/6 (angle between 0 and 30deg)
        // TODO: fairly untested
        for (var i = 0; i < 2 && mirrorM>=1/ROOT3; i++) {
          mirrorM=(mirrorM-1/ROOT3)/(1+mirrorM/ROOT3);
        }
        for (var i = 0; i < 3 && mirrorM<0; i++) {
          mirrorM=(mirrorM+1/ROOT3)/(1-mirrorM/ROOT3);
        }

        // mirrorM=Math.abs(mirrorM);
        // if (mirrorM<0) {
        //   console.log("mirrorM<0");
        //   console.log(mirrorM);
        //   mirrorM=(mirrorM+ROOT3)/(1-mirrorM*ROOT3);
        //   console.log(mirrorM);
        // }
        // if (mirrorM<0) {
        //   mirrorM=(mirrorM+ROOT3)/(1-mirrorM*ROOT3);
        // }
        // if (mirrorM>ROOT3) {
        //   // console.log(mirrorM, Math.tan(Math.atan(mirrorM)-TAU/6));// TODO: not working
        //   // mirrorM=(mirrorM-ROOT3/2)/(1+mirrorM*ROOT3/2);
        //   mirrorM=1/ROOT3-4/(3*mirrorM+ROOT3);
        //   // mirrorM=Math.tan(Math.atan(mirrorM)-TAU/6);
        // }
        // else if (mirrorM>1/ROOT3) {
        //   // console.log(mirrorM, Math.tan(Math.atan(mirrorM)-TAU/6));// TODO: not working
        //   // mirrorM=(mirrorM-ROOT3/2)/(1+mirrorM*ROOT3/2);
        //   // mirrorM=4/(3*mirrorM+ROOT3)-1/ROOT3;
        //   mirrorM=(ROOT3-mirrorM)/(1+ROOT3*mirrorM);
        //   // mirrorM=Math.tan(Math.atan(mirrorM)-TAU/6);
        // }
        // console.log(mirrorM);
      }
      setInTileTransforms();
      clearAll();
    }

    // TODO: dynamically set as many as are needed with the current canvas size
    // TODO: scaling based on selected tiling (some euclidean tilings naturally appear bigger than others due to unit edge lengths and different polygons)
    function setTilingTransforms(name=tilingTypeName) {//define the hyperbolic translations used to make the tiling (it applied to each point of the central tile) (like 6 equally spaced, unrotated copies at distance 1, to make a hexagonal tiling)
      // console.trace("name:", name);
      // if (!initialDrawingReady) return;
      globalScaling=1;
      if (isEuclidean && (name=="hypTest" || name=="regular using schlafli" || name=="anisohedral")) {
        globalScaling=0.5;
      }
      else if (curvature==1) {
        globalScaling=0.3;
      }
      switch (name) {
        case "none":
          // tilingTransforms=[new Affine2()];
          tilingTransforms=[new HypTransform()];
          break;
        case "hypTest":
          tilingTransforms=[
            new HypTransform(),
            // new HypTransform(0,0,0.01),
            new HypTransform(4, 3, 0),
            new HypTransform(0, 2.5, 0),
            // new HypTransform(0, 0.01, 0),
          ]
          break;
        case "regular using schlafli":
          // tilingTransforms=[new HypTransform()];
          // for (var i = 0; i < schlafliP; i++) {//only the central tile and its neighbors
          //   tilingTransforms.push(new HypTransform(TAU*(i+0.5)/schlafliP, 2*centerToEdgeMidpointHyp, PI+TAU*i/schlafliP));
          // }
          
          tilingTransforms=[];
          for (var i = 0; i < numPolys; i++) {
            if (true) {
            // if (P[i].layer==0 || P[i].layer==4) {
            // if (P[i].layer<=1) {
            // if (P[i].layer<=2) {
            // if (P[i].layer==1) {
            // if (i==0) {
              tilingTransforms.push(new HypTransform(P[i].centerAngFromXAxis, P[i].centerToOriginHyp, P[i].vertexOffsetAngle));
            }
          }
          break;
        case "anisohedral":
          tilingTransforms=[//squareflake tiling, "2-colored" with two different rotations
            new HypTransform(0, 0, 0),
            new HypTransform(0, 1, HPI/2),
            new HypTransform(HPI, 1, HPI/2),
            new HypTransform(HPI/2, ROOT2, 0),
          
            // new HypTransform(HPI/2, ROOT2/2, 0),
          ];
          
          // tilingTransforms=[//snowflakes, 3 rotations
          //   new HypTransform(0, 0, 0),
          //   new HypTransform(0, 1, TAU/6/3),
          //   new HypTransform(TAU/6, 1, TAU/6*2/3),
          //   new HypTransform(TAU*2/6, 1, TAU/6/3),
          //   new HypTransform(TAU*3/6, 1, TAU/6*2/3),
          //   new HypTransform(TAU*4/6, 1, TAU/6/3),
          //   new HypTransform(TAU*5/6, 1, TAU/6*2/3),
          //   new HypTransform(TAU/6/2, ROOT3, 0),
          // ];
          // tilingTransforms=[//snowflakes, 3 rotations
          //   new HypTransform(0, 0, 0),
          //   new HypTransform(0, 1, TAU/3/3),
          //   new HypTransform(TAU/6, 1, TAU/3*2/3),
          //   new HypTransform(TAU*2/6, 1, TAU/3/3),
          //   new HypTransform(TAU*3/6, 1, TAU/3*2/3),
          //   new HypTransform(TAU*4/6, 1, TAU/3/3),
          //   new HypTransform(TAU*5/6, 1, TAU/3*2/3),
          // ];
          
          // // let rot=TAU/6/2;
          // // let rot1=0.5;
          // let rot2=TAU/6/2;
          // tilingTransforms=[//snowflakes, 2 rotations
          //   new HypTransform(0, 0, 0),
          //   new HypTransform(0, 1, 0),
          //   new HypTransform(TAU/6, 1, rot2),
          //   new HypTransform(TAU*2/6, 1, 0),
          //   new HypTransform(TAU*3/6, 1, rot2),
          //   new HypTransform(TAU*4/6, 1, 0),
          //   new HypTransform(TAU*5/6, 1, rot2),
          // ];
          break;
        default:
          alert("this shouldn't have happened! (invalid tiling type)");
      }
      updateAutoGenerateButton();
    }
    function updateTilingType() {//set the tiling type from the tiling type input, setTilingTransforms() and clearAll()
      const rbs=document.querySelectorAll('input[name="tiling-type"]');// TODO: refactor
      for (const rb of rbs) {
        if (rb.checked) {
          tilingTypeName=rb.value;
          tilingTypeIndex=rb.id.slice(12);// TODO: kinda bad
          break;
        }
      }
      setTilingTransforms();
      clearAll();
    }

    function autoGenerateVertexesGeometrically(ctx=context) {//a geometrical (and unreliable) method of generating a snowflakes' vertexes (using mirrorM) // TODO: i don't remember how this works, and it's currently broken
      if (!canAutoGenerateGeometrically()) return;
      // let transf=inTileTransforms;
      
      let transf=[
        inTileTransforms[9],
        inTileTransforms[10]
      ]
      // transf[3]=new Vec2();
      var pos=new Vec2(1/2, ROOT3/6);
      // drawPointAtPosition(pos);
      var curFlakeVertArr=[pos];
      var curFlakeMinimalVertArr=[pos];
      for (var ii = 0; ii < 2000; ii++) {
        var bestDist=Infinity;
        var bestPoint=new Vec2();
        drawPointAtPosition(pos);
        var tPoints=[];
        var tPointTransforms=[];
        for (var i = 0; i < transf.length; i++) {
          // console.log("%c"+i, "font-size:20px", transf[i]);
          var t=transf[i];
          tPoints.push(new Vec2(t[0]*pos.x+t[1]*pos.y, t[2]*pos.x+t[3]*pos.y));
          tPointTransforms.push(tPoints[i].add(new Vec2(1, 0)));
          // console.log("tPoints[i]", tPoints[i]);
          // var tPoints[i]=tPoints[i].add(new Vec2(tilingTransforms[1].x, tilingTransforms[1].y));
        }
        // TODO: This uses a loop over transf and a loop over tPoints, which could (and later should) be put into one loop, but it's currently like this for understandability/debugging purposes.
        for (var i = 0; i < tPoints.length; i++) {
          let isCopyOfACentralVertex=false;
          for (var vertIndex = 0; vertIndex < curFlakeVertArr.length; vertIndex++) {
            if (curFlakeVertArr[vertIndex].sqDist(tPoints[i])<0.000000001) {// TODO: use an epsilon
              isCopyOfACentralVertex=true;
              // console.log("%cCopy info:", "color:#f90; font-size:15px", curFlakeVertArr[vertIndex], tPoints[i]);
              break;
            }
          }
          if (!isCopyOfACentralVertex) {
            curFlakeVertArr.push(tPoints[i]);// TODO: only if not a copy
            // console.log("isCopy", isCopyOfACentralVertex);

            // // context.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).lighten(0.2).rgb();
            // // ctx.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).rgb();
            // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.mult(0.6).rgb();
            // // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : colorLerp(fillColorWithErase, ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1), 0.3).rgb();// TODO: tilingTransforms no longer working
            // // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.multColor(ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1)).rgb();
            // // ctx.fillStyle=fillColorWithErase.rgb();
            // // var offPoint=tPoints[i];
            // var offsetDist=1;
            // var offPoint=tPoints[i].add(new Vec2(offsetDist*tilingTransforms[sh].x, offsetDist*tilingTransforms[sh].y));
            //
            // // drawSquare(offPoint.x, offPoint.y, drawSize);
            // drawDisk(offPoint.x, offPoint.y, drawSize, ctx);

            if (tPointTransforms[i].len()<bestDist) {
              bestPoint=tPointTransforms[i];
              bestDist=tPointTransforms[i].len();
            }
          }
        }

        if (bestPoint.len()<0.000001) {// TODO: epsilon
          // console.log("Non-copying point not found (or some other problem)");
          break;
        }
        pos=bestPoint;
        curFlakeMinimalVertArr.push(bestPoint.copy());
      }
      // console.log(curFlakeVertArr);
      // console.log(curFlakeMinimalVertArr);
      // console.log(curFlakeMinimalVertArr.length);
      // console.log("%c..............................................................................................................", "background:#fff");
    }

    function drawPointAtPosition(pos, ctx=context) {//given a (unscreen) point, draw it in all symmetries. used mainly for user drawing
      // context.fillStyle="rgb(200, 200, 220)";
      // context.fillStyle="hsla("+lerp(getNoise(colorChangeSteps*colorChangeSpeed, 0.1, 1.5924), 100, 300)+", 80%, 70%, 0.3)";
      // context.fillStyle=fillColor;
      for (var i = 0; i < inTileTransforms.length; i++) {
        var t=inTileTransforms[i];
        var tPoint=new Vec2(t[0]*pos.x+t[1]*pos.y, t[2]*pos.x+t[3]*pos.y);
        // for (var sX = -1; sX < 2; sX++) {
        //   for (var sY = -1; sY < 2; sY++) {
        //     // context.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).lighten(0.2).rgb();
        //     // ctx.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).rgb();
        //     ctx.fillStyle= (sX==0 && sY==0) ? fillColorWithErase.rgb() : fillColorWithErase.mult(0.6).rgb();
        //     // ctx.fillStyle=fillColorWithErase.rgb();
        //     // var offPoint=tPoint;
        //     var offsetDist=1;
        //     var offPoint=tPoint.add(new Vec2(offsetDist*(sX+sY/2), offsetDist*sY*ROOT3/2));
        //
        //     // drawSquare(offPoint.x, offPoint.y, drawSize);
        //     drawDisk(offPoint.x, offPoint.y, drawSize, ctx);
        //   }
        // }
        for (var sh = 0; sh < tilingTransforms.length; sh++) {
          // context.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).lighten(0.2).rgb();
          // ctx.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).rgb();
          ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.mult(0.6).rgb();
          // console.log(ctx.fillStyle);
          // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : colorLerp(fillColorWithErase, ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1), 0.3).rgb();
          // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.multColor(ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1)).rgb();
          // ctx.fillStyle=fillColorWithErase.rgb();
          // var offPoint=tPoint;
          // var offPoint=tPoint.add(new Vec2(offsetDist*tilingTransforms[sh].x, offsetDist*tilingTransforms[sh].y));
          var offPoint=tilingTransforms[sh].applyTo(tPoint).mult(globalScaling);

          // if (sh==0) {
          //   drawSize+=2;
          // }
          // drawSquare(offPoint.x, offPoint.y, drawSize);
          drawDisk(offPoint.x, offPoint.y, drawSize, ctx);
          // if (sh==0) {
          //   drawSize-=2;
          // }
        }
      }
    }
    function drawAllPoints() {//draw everything that the user has drawn
      let lastPosNum=0;
      let savedColor=fillColorWithErase;// TODO: everything here is bad
      let savedSize=drawSize;
      for (var i = 0; i <= curMovement; i++) {
        let posNum=movements[i];
        fillColorWithErase=movementColors[i];
        drawSize=movementSizes[i];
        for (var j = lastPosNum; j < posNum; j++) {
          drawPointAtPosition(mousePositions[j]);
        }
        lastPosNum=posNum;
      }
      fillColorWithErase=savedColor;
      drawSize=savedSize;
    }
    function drawFromCurDSF() {//draw the current DSF using .drawToWholeScreen() or make a list with curDSF and operations on it
      // TODO: controlled by user
      curDSF.drawToWholeScreen();
      // generateDSFGrid();
    }

    function drawHypGrid() {//draw a simple hyperbolic grid // TODO: jankiness could be lessened with homogenous coordinates
      context.fillStyle=BGColor.rgb();
      context.fillRect(0, 0, canvas.width, height);
      if (!isEuclidean) {//draw boundary circle
        context.strokeStyle=boundaryCircleColor;
        context.lineWidth=1.5;
        context.beginPath();
        context.arc(canvas.width/2, height/2, height/2, 0, TAU);
        context.stroke();
      }
      
      if (true) {//Draw edges for each polygon
        for (var i=numPolys-1; i>=0; i--) {//all polygons (reverse order)
          // for (var i=0; i<numPolys; i++) {//all polygons
          drawGridPoly(P[i].verts)
        }
      }
      drawAllVerts();
    }
    
    function update() {//main loop, runs every frame, handles user drawing
      if (!paused) {
        if (fReqs>=frameSkip) {
          changingContext.clearRect(0, 0, canvas.width, height);
          
          // let ctx=changingContext;
          // ctx.beginPath();
          // // ctx.fillStyle="#f0f";
          // ctx.strokeStyle="#f0f";
          // ctx.lineWidth=2;
          // let p1Ang=0; let p1Len=0;
          // let p2Ang=0; let p2Len=2;
          // // let p3Ang=2; let p3Len=1;
          // let a=p2Len;
          // let C=colorChangeSteps/20-2*TAU;
          // let b=2;
          //
          // let p3Ang=hypSASGetAngleAtFirstSide(a, C, b);
          // // console.log(p3Ang);
          // // if (p3Ang<0) {
          // //   p3Ang+=PI;
          // // }
          // // let p3Ang=1;
          // let p3Len=hypSASGetThirdEdge(a, C, b);
          // // let p3Len=1;
          //
          // let p1Vec=Vec2FromAngleAndHypLength(p1Ang, p1Len);
          // let p2Vec=Vec2FromAngleAndHypLength(p2Ang, p2Len);
          // let p3Vec=Vec2FromAngleAndHypLength(p3Ang, p3Len);
          // let p1Screen=p1Vec.screen();
          // // let p2Screen=p2Vec.screen();
          // // let p3Screen=p3Vec.screen();
          // ctx.moveTo(p1Screen.x, p1Screen.y);
          // pathPoincareEdge(p1Vec, p2Vec, ctx);
          // pathPoincareEdge(p2Vec, p3Vec, ctx);
          // pathPoincareEdge(p3Vec, p1Vec, ctx);
          // ctx.stroke();
          
          // curDSF.segmentLength=(-colorChangeSteps/500%1+1)%1 *0.1;
          // drawFromCurDSF();
          
          // // Testing whether HypTransform works // TODO: looks like it does, but the values created during graph generation are incorrect
          // // let timeUnits=colorChangeSteps/10;
          // let timeUnits=colorChangeSteps/20;
          // // console.log("");
          // // let transf=new HypTransform(timeUnits, HPI, 0);
          // // let transf=new HypTransform(0, HPI, 0);
          // // let transf=new HypTransform(-1.04, 1.23096, 1);
          // // let transf=new HypTransform(-PI, 1.23096, 1);
          // let transf=new HypTransform(-1.04*5, 1.23096, 1);
          // // let point1=new Vec2(0, 0);
          // // let point1=new Vec2(0, 1);
          // let point1=new Vec2(0.355, -0.615);
          // let point2=transf.applyTo(point1)
          // // console.log(transf);
          // // console.log(point2);
          // let screen1=point1.mult(globalScaling).screen();
          // let screen2=point2.mult(globalScaling).screen();
          // // context.fillStyle="red";
          // // context.fillRect(screen1.x-3,screen1.y-3,6,6);
          // // context.fillRect(screen2.x-3,screen2.y-3,6,6);
          // changingContext.fillStyle="red";
          // changingContext.fillRect(screen1.x-3,screen1.y-3,6,6);
          // changingContext.fillRect(screen2.x-3,screen2.y-3,6,6);
          
          
          // let generatedDSFUpdateFrames=8;
          // if (colorChangeSteps%generatedDSFUpdateFrames==0) {
          //   let numTestOps=5;
          //   let binStr="";
          //   let opStr="e1";
          //   let binSeed=Math.round(colorChangeSteps/generatedDSFUpdateFrames);
          //   // console.log(binSeed);
          //   for (var j = 0; j < numTestOps; j++) {
          //     if (1<<j & binSeed) {
          //       binStr+="1";
          //       opStr+="e1";
          //     }
          //     else {
          //       binStr+="0";
          //       opStr+="e0";
          //     }
          //   }
          //
          //   opStr+="s1";
          //   // console.log(binStr);
          //   dsfOperationsInput.value=opStr;
          //   updateCurDSFOperations();
          //   // console.log(opStr);
          //   // let dsf=getDSFFromOperations(opStr);
          //   // curDSF=dsf;
          // }
          
          
          // let mouseScreenPos=mousePos.unscreen();//mouse position, no longer in screen coordinates
          let mouseScreenPos=mousePos.unscreen().div(globalScaling);//mouse position, no longer in screen coordinates // TODO: rename
          if (mouseDown) {
            // fReqs=0;
            // console.log(fReqs);
            
            // for (var i = 0; i < 20; i++) {
            //   if (true) {//do calculations
            //     mouseScreenPos=mouseScreenPos.add(new Vec2(rand0(maxStep), rand0(maxStep))).mult(distFactor);
            //   }
            //   draw();// TODO: this commented block could be fixed, but is it useful? (btw draw probably needs to be outside the for)
            //   colorChangeSteps++;
            // }
            
            mousePositions.push(mouseScreenPos);
            drawPointAtPosition(mouseScreenPos);
            // colorChangeSteps++;
          }
          else {
            drawPointAtPosition(mouseScreenPos, changingContext);
          }
          
          colorChangeSteps++;
          fReqs-=frameSkip;
        }
        fReqs++;
        window.requestAnimationFrame(update);
      }
    }

    function updateSchlafliSymbol() {//set schlafliSymbol from the schlafliInputContainer, change dependent variable
      let newSchlafliSymbol=[parseInt(schlafliPInput.value), parseInt(schlafliQInput.value)];
      let schlafliSymbolChanged=true;
      if( //if the input values are reasonable, change variables accordingly
          newSchlafliSymbol[0]>=3 && newSchlafliSymbol[0]<=30
          && newSchlafliSymbol[1]>=3 && newSchlafliSymbol[1]<=30
          // && (newSchlafliSymbol[0]-2)*(newSchlafliSymbol[1]-2)>=4
        )
        {// TODO: change arbitrary limits (particularly upper ones) // TODO: allow spherical geometry too!
          schlafliInputContainer.style.backgroundColor="";
          if (arraysShallowEqual(schlafliSymbol, newSchlafliSymbol)) schlafliSymbolChanged=false;
          schlafliSymbol=newSchlafliSymbol;
          schlafliP=schlafliSymbol[0];
          schlafliQ=schlafliSymbol[1];
        }
        else {
          schlafliInputContainer.style.backgroundColor="rgb(240, 80, 80)";
        }
        
      if (schlafliSymbolChanged) {
        generateHyperbolicGraph();
        setInTileTransforms();
        setTilingTransforms();
        setDSFStuff();
        clearAll();
      }
      return schlafliSymbolChanged;
    }
    function generateHyperbolicGraph() {//generate V and P, the vertexes and polygons of the hyperbolic grid
      // TODO: where is this all from? (i figured a lot of it out, but there must be something to cite)
      // TODO: redefine objects only when schlafliSymbol changes
      if (true){// initial object definition (first polygon and vertexes with positions)
        P=[new Polygon()];//Polygons array
        V=[];//Vertexes array
        for (var i = 0; i < schlafliP; i++)
          V[i]=new Vert();
        for (var i = 0; i < schlafliP; i++) {
          P[0].addVert(i);
          V[i].addPoly(0);
          V[i].addNext((i+1)%schlafliP);
          V[(i+1)%schlafliP].addNext(i);
        }
        numVerts=schlafliP;
        numPolys=1;

        let curvatureDeterminer=(schlafliP-2)*(schlafliQ-2);
        if (curvatureDeterminer>4) {//hyperbolic
          isEuclidean=false; curvature=-1;
          
          //formula taken from http://www.malinc.se/noneuclidean/en/poincaretiling.php#formula on 16.07.2021
          centerToVertexEuc=Math.sqrt((Math.tan(PI / 2 - PI / schlafliQ) - Math.tan(PI / schlafliP)) / (Math.tan(PI / 2 - PI / schlafliQ) + Math.tan(PI / schlafliP)));
          
          // TODO: where is this from?
          edgeLengthHyp=Math.acosh(1+2*((1-Math.cos(TAU/schlafliP))**2+Math.sin(TAU/schlafliP)**2)*centerToVertexEuc**2/( (1-centerToVertexEuc**2)**2 ));
          
          centerToEdgeMidpointEuc=hypToEucDist(hypSASGetThirdEdge(eucToHypDist(centerToVertexEuc), PI/schlafliQ, edgeLengthHyp/2));
        }
        else if (curvatureDeterminer==4) {//euclidean
          isEuclidean=true; curvature=0;

          centerToVertexEuc=0.5/Math.sin(PI/schlafliP);
          
          centerToEdgeMidpointEuc=0.5/Math.tan(PI/schlafliP);
          
          edgeLengthHyp=1;
        }
        else if (curvatureDeterminer>0) {//spherical
          isEuclidean=false; curvature=1;
          
          function sphAAAGetSideOppositeFirstAngle(A, B, C) {// TODO: global function for all geometries?
            //formula adapted from "Spherical Trigonometry: For the Use of Colleges and Schools by I. Todhunter", retrieved 28.07.2021 from https://www.gutenberg.org/ebooks/19770
            return Math.acos( (Math.cos(A)+Math.cos(B)*Math.cos(C)) / (Math.sin(B)*Math.sin(C)) );
          }
          
          centerToVertexEuc=hypToEucDist(sphAAAGetSideOppositeFirstAngle(HPI, PI/schlafliQ, PI/schlafliP));

          centerToEdgeMidpointEuc=hypToEucDist(sphAAAGetSideOppositeFirstAngle(PI/schlafliQ, PI/schlafliP, HPI));
          
          edgeLengthHyp=2*sphAAAGetSideOppositeFirstAngle(PI/schlafliP, PI/schlafliQ, HPI);
        }
        else {//error
          alert("alert006 invalid schlafli symbol");
        }
        // console.log(d, edgeLengthHyp);
        
        centerToVertexHyp=eucToHypDist(centerToVertexEuc);
        centerToEdgeMidpointHyp=eucToHypDist(centerToEdgeMidpointEuc);
        
        for (var i=0; i<schlafliP; i++) {//first polygon position
          // let offsetAng=0; let offsetX=0.02; let offsetY=0.01;//c++ version, causes problems near borders
          // let offsetAng=0; let offsetX=0.001; let offsetY=0.002;//stable
          // let offsetAng=0.001; let offsetX=0.0001; let offsetY=0.00002;//extra stable?
          // let offsetAng=0.05; let offsetX=0; let offsetY=0;//newly stable
          // let offsetAng=0.001; let offsetX=0; let offsetY=0;
          // let offsetAng=0.0000000001; let offsetX=0; let offsetY=0;//newly stable? (doesn't work for metasquares polygon checking)
          let offsetAng=0; let offsetX=0; let offsetY=0;// TODO: i think this works now, can i delete these offsets?

          V[i].setPos(new Vec2(centerToVertexEuc*Math.cos(i*TAU/schlafliP+offsetAng)+offsetX, -centerToVertexEuc*Math.sin(i*TAU/schlafliP+offsetAng)+offsetY));
        }
      }
      // for (var k=0; k<2; k++) {// graph generation //k is the index of the polygon from which new polygons are being generated
      // for (var k=0; k<1+schlafliP+50; k++) {// GRAPH generation //k is the index of the polygon from which new polygons are being generated
      // for (var k=0; k<1+schlafliP; k++) {// GRAPH generation //k is the index of the polygon from which new polygons are being generated
      for (var k=0; k<20; k++) {// graph generation //k is the index of the polygon from which new polygons are being generated
        // for (var k=0; k<1; k++) {// graph generation //k is the index of the polygon from which new polygons are being generated
        // console.log("%ck="+k, "color:lime; font-size:200%");
        // console.log(k, "/", P.length);
        if (typeof(P[k])==="undefined") break;//this polygon is undefined, presumably means that a sphere has been completed
        if (P[k].numNext==schlafliP) continue;//don't make new polygons if the current polygon already has all neighbors, similar to previous but happens sooner
        for (var i=0; i<schlafliP; i++) {//edges
          // console.log(i);
          // console.log("%ci="+i, "color:lime; font-size:140%");
          //don't make new polygon towards parent (the first polygon doesn't have a parent)
          if (k!=0 && i==0) continue;
          //get first 2 vertexes of new polygon (usually pointing towards the parent)
          var v1=P[k].verts[(1+i)%schlafliP];// TODO: rename? (v0 and v1)
          var v2=P[k].verts[i];
          
          //don't make new polygon if either vertex has already been filled
          if (V[v1].numPolys==schlafliQ || V[v2].numPolys==schlafliQ) continue;
          
          P[numPolys]=new Polygon();
          P[numPolys].layer=P[k].layer+1;
          
          let numNewVertsNeeded=schlafliP-2;
          
          function findNextVertInLoop(curVert, previousVert) {
            let curCandidate=undefined;// TODO: undefined isn't necessary?
            for (var i = 0; i < V[curVert].numNext; i++) {
              let potentialNewVert=V[curVert].next[i];//new vertex, need to check whether it is not the same as the current vertex and that it has the correct number of polygons
              // console.log("V[curVert].next[i]", V[curVert].next[i], "V[curVert].next", V[curVert].next, "V[curVert]", V[curVert]);
              let numPolysShared=0;
              for (var j = 0; j < V[potentialNewVert].polys.length; j++) {
                if (arrayContains(V[curVert].polys, V[potentialNewVert].polys[j])) numPolysShared++;
              }
              // if (potentialNewVert==previousVert || potentialNewVert<schlafliP) {//old and bad
              if (potentialNewVert==previousVert || numPolysShared!=1) {//potentialNewVert shares two polygons with potentialNewVert, it's not valid (either the same or goes across an edge with both polygons present, which isn't the case for the desired vertex)
                if (numPolysShared==0 || numPolysShared>2) {
                  alert("alert009 two adjacent vertexes share "+numPolysShared+" polygons");
                }
                continue;
              }
              if (typeof(curCandidate)!="undefined") {// TODO: maybe this will never trigger and should be removed, plus uncommenting the "break;"
                alert("alert007 multiple vertexes that don't have all polygons")
              }
              curCandidate=potentialNewVert;
              // break;
            }
            return curCandidate;
          }
          
          let curFurthestClockwiseVert=v2;
          let curFurthestWiddershinsVert=v1;
          let vertLoopBeginning=[];
          let vertLoopEnding=[];
          let widdershinsFromCurFurthestClockwiseVert=v1;//keep track of the vertex that is just widdershins of curFurthestClockwiseVert
          let clockwiseFromCurFurthestWiddershinsVert=v2;//keep track of the vertex that is just clockwise of curFurthestWiddershinsVert
          
          let vertLoop=[];
          let vertArc=[];
          let neighborVertArc=[];
          
          // if (V[curFurthestClockwiseVert].numPolys==schlafliQ-1) {//the vertex from which i am searching has the right number of polygons
          //   // let newFurthestClockwiseVert=undefined;
          //   // for (var potentialNewPolyRelativeIndex = 0; potentialNewPolyRelativeIndex < V[curFurthestClockwiseVert].numNext; potentialNewPolyRelativeIndex++) {// TODO: rename
          //   //   let potentialNewVert=V[curFurthestClockwiseVert].next[potentialNewPolyRelativeIndex];//new vertex, need to check whether it is not the same as the current vertex and that it has the correct number of polygons
          //   //   console.log("potentialNewVert", potentialNewVert, "widdershinsFromCurFurthestClockwiseVert", widdershinsFromCurFurthestClockwiseVert);
          //   //   if (potentialNewVert==widdershinsFromCurFurthestClockwiseVert) {//potentialNewVert is widdershins of curFurthestClockwiseVert, try another one // TODO: not actually v1
          //   //     continue;
          //   //   }
          //   //   if (V[potentialNewVert].numPolys==schlafliQ-1) {
          //   //     if (typeof(newFurthestClockwiseVert)!="undefined") {// TODO: maybe this will never trigger and should be removed
          //   //       alert("alert007 multiple vertexes that don't have all polygons")
          //   //     }
          //   //     newFurthestClockwiseVert=curFurthestClockwiseVert;
          //   //     // break;
          //   //   }
          //   // }
          //   let newFurthestClockwiseVert=findNextVertInLoop(curFurthestClockwiseVert, widdershinsFromCurFurthestClockwiseVert);
          //   console.log("newFurthestClockwiseVert in if", newFurthestClockwiseVert);
          //   if (typeof(newFurthestClockwiseVert)!="undefined") {//a valid vertex was found
          //     //add the vertex previously thought to be furthest as a vertex of the new polygon
          //     vertLoopBeginning.push(curFurthestClockwiseVert);
          //
          //     widdershinsFromCurFurthestClockwiseVert=curFurthestClockwiseVert;
          //     curFurthestClockwiseVert=newFurthestClockwiseVert;
          //     console.log("numNewVertsNeeded--; from clockwise");
          //     numNewVertsNeeded--;
          //   }
          // }
          
          for (var ii = 0; ii < schlafliP; ii++) {//find all vertexes belonging to the current polygon, clockwise from the parent vertexes. limit in case looking for the next vertex loops endlessly
            if (V[curFurthestClockwiseVert].numPolys!=schlafliQ-1) {//the vertex from which i am searching has the right number of polygons
              break;
            }
            let newFurthestClockwiseVert=findNextVertInLoop(curFurthestClockwiseVert, widdershinsFromCurFurthestClockwiseVert);
            if (typeof(newFurthestClockwiseVert)=="undefined") {
              break;
            }
            //add the vertex previously thought to be furthest as a vertex of the new polygon
            vertLoopBeginning.push(curFurthestClockwiseVert);
            
            widdershinsFromCurFurthestClockwiseVert=curFurthestClockwiseVert;
            curFurthestClockwiseVert=newFurthestClockwiseVert;
            // console.log("numNewVertsNeeded--; from clockwise");
            numNewVertsNeeded--;
          }
          
          if (vertLoopBeginning.length==schlafliP) {//a cycle of existing vertexes has been found
            // console.log("Loop!");
            vertLoop=[v1].concat(vertLoopBeginning); vertLoop.pop();//vertLoop is like vertLoopBeginning (which is the entire loop) but shifted over by one
            neighborVertArc=[v1].concat(vertLoopBeginning);
          }
          else {
            // console.log("curFurthestClockwiseVert", curFurthestClockwiseVert);
            
            
            for (var ii = 0; ii < schlafliP; ii++) {//find all vertexes belonging to the current polygon, widdershins from the parent vertexes. limit is somewhat arbitrary
              if (V[curFurthestWiddershinsVert].numPolys!=schlafliQ-1) {//the vertex from which i am searching has the right number of polygons
                break;
              }
              // for (var potentialNewPolyRelativeIndex = 0; potentialNewPolyRelativeIndex < V[curFurthestWiddershinsVert].numNext; potentialNewPolyRelativeIndex++) {
              //   let potentialNewVert=V[curFurthestWiddershinsVert].next[potentialNewPolyRelativeIndex];//new vertex, need to check whether it is not the same as the current vertex and that it has the correct number of polygons
              //   if (potentialNewVert==v2) {//potentialNewVert is the same as the last vertex, try another one
              //     continue;
              //   }
              //   if (V[potentialNewVert].numPolys==schlafliQ-1) {
              //     if (typeof(newFurthestWiddershinsVert)!="undefined") {
              //       alert("alert007 multiple vertexes that don't have all polygons")
              //     }
              //     newFurthestWiddershinsVert=curFurthestWiddershinsVert;
              //     // break;
              //   }
              // }
              let newFurthestWiddershinsVert=findNextVertInLoop(curFurthestWiddershinsVert, clockwiseFromCurFurthestWiddershinsVert);
              if (typeof(newFurthestWiddershinsVert)=="undefined") {
                break;
              }
              //add the vertex previously thought to be furthest as a vertex of the new polygon
              vertLoopEnding.unshift(curFurthestWiddershinsVert);
              
              clockwiseFromCurFurthestWiddershinsVert=curFurthestWiddershinsVert;
              curFurthestWiddershinsVert=newFurthestWiddershinsVert;
              // console.log("numNewVertsNeeded--; from widdershins");
              numNewVertsNeeded--;
            }
            
            vertArc=[curFurthestClockwiseVert];
            for (var j = 0; j < numNewVertsNeeded; j++) {
              var newVert=numVerts;
              V[newVert]=new Vert();
              vertArc.push(newVert);
              // V[newVert].addPoly(numPolys);
              // P[numPolys].addVert(newVert);
              numVerts++;
            }
            vertArc.push(curFurthestWiddershinsVert)
            
            // let vertLoop=[];
            // if (vertLoopEnding.length==0) {
            //   vertLoopBeginning.concat(vertArc)
            // }
            // else {
            //   [vertLoopEnding[vertLoopEnding.length-1]].concat(vertLoopBeginning).concat(vertArc).concat(vertLoopEnding)
            // }
            vertLoop=vertLoopEnding.length==0 ? [vertArc[vertArc.length-1]].concat(vertLoopBeginning).concat(vertArc) : [vertLoopEnding[vertLoopEnding.length-1]].concat(vertLoopBeginning).concat(vertArc).concat(vertLoopEnding);// TODO: do the edge cases work?
            vertLoop.pop();
            neighborVertArc=[vertArc[vertArc.length-1]].concat(vertLoopEnding).concat(vertLoopBeginning).concat([vertArc[0]]);//vertexes that already belong to neighbors of the current polygon, used to add neighborship
          }
          
          // console.log("numNewVertsNeeded", numNewVertsNeeded);
          //
          // console.log(vertArc);
          //
          // console.log("vert loop parts", vertLoopBeginning, vertLoopEnding);
          // console.log(vertLoop, neighborVertArc);
          
          //add neighbors of the current polygon
          for (var ii = 1; ii < neighborVertArc.length; ii++) {
            let curPolys=V[neighborVertArc[ii-1]].polys;//potential polygons which have the first needed vertex, one of which also has the other
            let resPoly;
            for (var jj = 0; jj < curPolys.length; jj++) {
              if (arrayContains(P[curPolys[jj]].verts, neighborVertArc[ii])) {
                if (typeof(resPoly)!="undefined") {
                  alert("alert008 multiple polygons with two given vertexes");
                }
                resPoly=curPolys[jj];
                break;
              }
            }
            P[resPoly].addNext(numPolys);
            P[numPolys].addNext(resPoly);
          }
          {//swap the first poly in the neighbor array with the parent poly (so that the parent polygon is the first in the array, this is relevant for vertex position generation and further sorting)
            let parentPolyFromNeighbors=P[numPolys].next[vertLoopEnding.length];
            P[numPolys].next[vertLoopEnding.length]=P[numPolys].next[0];
            P[numPolys].next[0]=parentPolyFromNeighbors
          }
          
          //add vertexes of the current polygon
          for (var addedVertIndex = 0; addedVertIndex < vertLoop.length; addedVertIndex++) {
            V[vertLoop[addedVertIndex]].addPoly(numPolys);
            P[numPolys].addVert(vertLoop[addedVertIndex]);
          }
          
          // if (k==4) {
          //   // console.log(makeV3, makeV4);
          //   console.log("gggggggggggggg");
          // }
          //
          // var makeV3=V[v2].numNext<schlafliQ;
          // var makeV4=V[v1].numNext<schlafliQ;
          //
          // // console.log(makeV3, makeV4, "via "+V[v1].numNext+", "+V[v2].numNext+" <? "+schlafliQ);
          //
          // var vertArc=[];
          // if (makeV3) {
          //   vertArc.push(v2);
          // }
          // else {
          //   vertArc.push(V[v2].next[schlafliQ-1]);
          //
          //   V[vertArc[0]].addPoly(numPolys);
          //   P[numPolys].addVert(vertArc[0]);
          //
          //   P[V[v2].polys[V[v2].numPolys-2]].addNext(numPolys);
          //   P[numPolys].addNext(V[v2].polys[V[v2].numPolys-2]);
          // }
          //
          // // for (var j = 4-makeV3-makeV4; j < schlafliP; j++) {
          // for (var j = 0; j < schlafliP-4+makeV3+makeV4; j++) {
          //   var newVert=numVerts;
          //   V[newVert]=new Vert();
          //   vertArc.push(newVert);
          //   V[newVert].addPoly(numPolys);
          //   P[numPolys].addVert(newVert);
          //   numVerts++;
          // }
          //
          // if (makeV4) {
          //   vertArc.push(v1);
          // }
          // else {
          //   vertArc.push(V[v1].next[schlafliQ-1]);
          //
          //   V[vertArc[vertArc.length-1]].addPoly(numPolys);
          //   P[numPolys].addVert(vertArc[vertArc.length-1]);
          //
          //   P[V[v1].polys[V[v1].numPolys-2]].addNext(numPolys);
          //   P[numPolys].addNext(V[v1].polys[V[v1].numPolys-2]);
          // }
          
          for (var j = 1; j < vertArc.length; j++) {
            if (!(vertArc[j]==vertArc[j-1] || arrayContains(V[vertArc[j]].next, vertArc[j-1]))) {
            // if (!arrayContains(V[vertArc[j]].next, vertArc[j-1])) {
              // console.log(V[vertArc[j]]);
              // console.log(arrayContains(V[vertArc[j]].next, vertArc[j-1]));
              // console.log("    ", vertArc[j], "+", vertArc[j-1]);
              V[vertArc[j]].addNext(vertArc[j-1]);
              V[vertArc[j-1]].addNext(vertArc[j]);
            }
          }
          
          // console.log("");
          
          numPolys++;
        }
      }
      // TODO: is any of the ordering necessary?
      
      // for (var i = 0; i < P.length; i++) {// order the neighbors of the polygons
      //   let curPoly=P[i];
      //   let lastPolyIndex=curPoly.next[0];
      //   let newNextArray=[lastPolyIndex];
      //   for (var j = 1; j < schlafliP; j++) {
      //     for (var k = 0; k < ; k++) {
      //       [i]
      //     }
      //     newNextArray.push(lastPolyIndex);
      //   }
      // }
      
      // for (var i=0; i<numVerts; i++) {// order the vertexes
      //   let curV=V[i];
      //   var j=0;
      //   for (; j < curV.polys.length; j++) {
      //     let curPoly=P[curV.polys[j]];
      //     // console.log("curPoly", curV.polys[j]);
      //     let vertArr=curPoly.verts;
      //     let curVLocalIndex=indexOfElement(vertArr, i);
      //     // let widdVert=vertArr[(curVLocalIndex-1+schlafliP)%schlafliP];
      //     let widdVert=vertArr[(curVLocalIndex+1)%schlafliP];
      //     // console.log(widdVert);
      //     let k=0;
      //     for (; k < curV.polys.length; k++) {
      //       if (arrayContains(P[curV.polys[k]].verts, widdVert) && j!=k) {
      //         break;
      //       }
      //     }
      //     if (k==curV.polys.length) {
      //       // console.log("begin at", curV.polys[j]);
      //       break;
      //     }
      //     else {
      //       // console.log("ok");
      //     }
      //   }
      //
      //   let newNextArr=[];
      //   let newPolyArr=[];
      //   let curPairIndex=j;
      //   if (curPairIndex==curV.polys.length) {
      //     curPairIndex=0;
      //   }
      //   let pairs=[];
      //   let firstPairIndex=curPairIndex;
      //
      //   for (var j=0; j < curV.polys.length; j++) {
      //     let curPoly=P[curV.polys[j]];
      //     // console.log(curPolyIndex, curV.polys[curPolyIndex]);
      //     // console.log("curPoly", curV.polys[j]);
      //     let vertArr=curPoly.verts;
      //     let curVLocalIndex=indexOfElement(vertArr, i);
      //     let widdVert=vertArr[(curVLocalIndex-1+schlafliP)%schlafliP];
      //     let clockVert=vertArr[(curVLocalIndex+1)%schlafliP];
      //     // pairs.push([widdVert, clockVert]);
      //     pairs.push([clockVert, widdVert, curV.polys[j]]);
      //     // console.log(widdVert);
      //     // let k=0;
      //     // for (; k < curV.polys.length; k++) {
      //     //   if (arrayContains(P[curV.polys[k]].verts, widdVert) && j!=k) {
      //     //     break;
      //     //   }
      //     // }
      //     // if (k!=curV.polys.length) {//another polygon with the 2 vertexes was found
      //     //   if () {
      //     //   }
      //     //   else {
      //     //     newNextArr.push(widdVert);
      //     //     newPolyArr.push(curV.polys[k]);
      //     //     curPolyIndex=k;
      //     //   }
      //     // }
      //     // else {
      //     //   newNextArr.push(vertArr[(curVLocalIndex+1)%schlafliP]);
      //     //   break;
      //     // }
      //   }
      //
      //   // console.log(pairs);
      //
      //   while (curPairIndex!=firstPairIndex || newNextArr.length==0) {
      //     let curPair=pairs[curPairIndex];
      //     // console.log(curPairIndex, curPair);
      //     newNextArr.push(curPair[0]);
      //     newPolyArr.push(curPair[2]);
      //     for (var k=0; k < pairs.length; k++) {
      //       if (pairs[k][0]==curPair[1]) {
      //         curPairIndex=k;
      //         break;
      //       }
      //     }
      //     if (k==pairs.length) {
      //       newNextArr.push(curPair[1]);
      //       break;
      //     }
      //   }
      //
      //   // console.log("!!result!!", newNextArr, newPolyArr);
      //
      //   curV.next=newNextArr;
      //   curV.polys=newPolyArr;
      //
      //   // for (var j=0; j < curV.polys.length; j++) {
      //   //   let curPoly=P[curV.polys[curPolyIndex]];
      //   //   console.log(curPolyIndex, curV.polys[curPolyIndex]);
      //   //   // console.log("curPoly", curV.polys[j]);
      //   //   let vertArr=curPoly.verts;
      //   //   let curVLocalIndex=indexOfElement(vertArr, i);
      //   //   let widdVert=vertArr[(curVLocalIndex-1+schlafliP)%schlafliP];
      //   //   // console.log(widdVert);
      //   //   let k=0;
      //   //   for (; k < curV.polys.length; k++) {
      //   //     if (arrayContains(P[curV.polys[k]].verts, widdVert) && j!=k) {
      //   //       break;
      //   //     }
      //   //   }
      //   //   if (k!=curV.polys.length) {//another polygon with the 2 vertexes was found
      //   //     if () {
      //   //     }
      //   //     else {
      //   //       newNextArr.push(widdVert);
      //   //       newPolyArr.push(curV.polys[k]);
      //   //       curPolyIndex=k;
      //   //     }
      //   //   }
      //   //   else {
      //   //     newNextArr.push(vertArr[(curVLocalIndex+1)%schlafliP]);
      //   //     break;
      //   //   }
      //   // }
      //
      //   // let k=0;
      //   // let lastK=undefined;
      //   // let lastPoly=curV.polys[0];
      //   // let newNextArr=[];
      //   // let newPolysArr=[0];
      //   // do {
      //   //   let vertArr=P[lastPoly].verts;//verts array of the first parent polygon
      //   //   let lastVert=vertArr[(indexOfElement(vertArr, i)-1+schlafliQ)%schlafliQ];
      //   //   k=0;
      //   //   for (; k < curV.numPolys; k++) {//find another polygon with curV and last found vertex as its vertexes
      //   //     // console.log(P[curV.polys[k]].verts, lastVert);
      //   //     if (arrayContains(P[curV.polys[k]].verts, lastVert) && k!=lastK) {
      //   //       break;
      //   //     }
      //   //   }
      //   //
      //   //   if (k==curV.numPolys) {
      //   //     console.log("bad!!!!!!!!!!!!!!!!");
      //   //     break;
      //   //   }
      //   //   else {
      //   //     lastPoly=curV.polys[k];
      //   //     newPolysArr.push(lastPoly)
      //   //   }
      //   //   lastK=k;
      //   // } while (k!=0)
      //   //
      //   // console.log(i);
      //   // // console.log(curV.next);
      //   // // console.log(newNextArr);
      //   // console.log(curV.polys);
      //   // console.log(newPolysArr);
      //
      //   // let newNextArr=[];
      //   // let vertArr=P[curV.polys[0]].verts;//verts array of the first parent polygon
      //   // let lastVert=V[vertArr[(indexOfElement(vertArr, curV)-1+schlafliQ)%schlafliQ]];
      //   // while (true) {
      //   //   newNextArr.push(lastVert);
      //   //   vertArr=P[curV.polys[lastVert]].verts;//verts array of one of the parent polygons
      //   //   // newNextArr.push(vertArr[(indexOfElement(vertArr, i)-1+schlafliQ)%schlafliQ]);//get the element after curV in vertArr, add it to newNextArr
      //   //   var k=0;
      //   //   for (; k < curV.numPolys; k++) {//find another polygon with curV and last found vertex as its vertexes
      //   //     if (arrayContains(P[curV.polys[k]].verts, newNextArr[newNextArr.length-1]) && k!=j) {
      //   //       break;
      //   //     }
      //   //   }
      //   //   if (k==curV.numPolys) {
      //   //     console.log("bad!!!!!!!!!!!!!!!!");
      //   //     break;
      //   //   }
      //   //   else {
      //   //
      //   //   }
      //   //   let vertArr=P[curV.polys[0]].verts;
      //   //   let lastVert=V[vertArr[(indexOfElement(vertArr, curV)-1+schlafliQ)%schlafliQ]];
      //   //   console.log(indexOfElement(vertArr, i), (indexOfElement(vertArr, i)+1)%schlafliQ);
      //   // }
      //   // console.log(curV.next, newNextArr);
      //   // console.log("");
      // }
      
      for (var i=1; i<numPolys; i++) {// calculate vertex positions
        // console.log("%c"+P[i].next[0]+":", "font-size:160%; color:lime", i);
        let v1=P[i].verts[0];
        let v2=P[i].verts[1];
        let parentPoly=P[P[i].next[0]];
      
        // centerAngFromXAxis, centerToOriginHyp, vertexOffsetAngle
        let parentVertIndex=indexOfElement(parentPoly.verts, P[i].verts[0]);
        // let angleOriginToParentToChild=-PI-parentPoly.centerAngFromXAxis+(0.5-parentVertIndex)*TAU/schlafliP+parentPoly.vertexOffsetAngle;
        let angleOriginToParentToChild=-PI-parentPoly.centerAngFromXAxis+(0.5001-parentVertIndex)*TAU/schlafliP+parentPoly.vertexOffsetAngle;// TODO: something dislikes precise angles (in [6, 4], [8, 4], [10, 3])
        // let angleOriginToParentToChild=(parentVertIndex+0.5)*TAU/schlafliP+P[k].vertexOffsetAngle;// TODO: won't work, it's a simplified version of the above line
        // console.log("parentPoly.centerAngFromXAxis", parentPoly.centerAngFromXAxis, "parentVertIndex", parentVertIndex, "(1.5-parentVertIndex)*TAU/schlafliP", (1.5-parentVertIndex)*TAU/schlafliP, "parentPoly.vertexOffsetAngle", parentPoly.vertexOffsetAngle, "angleOriginToParentToChild", mod(angleOriginToParentToChild, TAU));
        // console.log("angleOriginToParentToChild", angleOriginToParentToChild);
        if (i<=schlafliP) {//the surrounding of the first tile // TODO: this case shouldn't be necessary, it's here for bugfixing
        // if (false) {
          P[i].centerAngFromXAxis=(0.5-i)*TAU/schlafliP;
          P[i].centerToOriginHyp=2*centerToEdgeMidpointHyp;
          // P[i].vertexOffsetAngle=PI+TAU*i/schlafliP;
          P[i].vertexOffsetAngle=PI+TAU*(1-i)/schlafliP;
          // console.log(P[i].centerAngFromXAxis);
          // console.log(i, P[i].next[0], P[i].vertexOffsetAngle);
        }
        else {
          console.log("%c"+i, "font-size:170%");
          console.log(parentPoly.centerToOriginHyp, angleOriginToParentToChild, 2*centerToEdgeMidpointHyp);
          console.log(parentPoly.centerAngFromXAxis, "-", hypSASGetAngleAtFirstSide(parentPoly.centerToOriginHyp, angleOriginToParentToChild, 2*centerToEdgeMidpointHyp));
          P[i].centerAngFromXAxis=parentPoly.centerAngFromXAxis-hypSASGetAngleAtFirstSide(parentPoly.centerToOriginHyp, angleOriginToParentToChild, 2*centerToEdgeMidpointHyp);
          P[i].centerToOriginHyp=hypSASGetThirdEdge(parentPoly.centerToOriginHyp, angleOriginToParentToChild, 2*centerToEdgeMidpointHyp);
      
          // P[i].vertexOffsetAngle=0;
          P[i].vertexOffsetAngle=new HypTransform(P[i].centerAngFromXAxis, -P[i].centerToOriginHyp).applyTo(V[P[i].verts[0]].pos).ang();
      
          // console.log("angleOriginToParentToChild", mod(angleOriginToParentToChild, TAU));
          // console.log(i, P[i].next[0], P[i].centerToOriginHyp);
        }
      
        let prevC, newR;
      
        if (!isEuclidean) {//calculate circle center
          prevC=getGeodesicCircleCenter(V[v1].pos, V[v2].pos);
          newR=(prevC.sub(V[v1].pos)).len();
      
          // TODO: prevC.x breaks when offsetAng is a multiple of HPI
          // console.log(prevC);
          // console.log("M", M);
          // console.log(M.y*(M.y-centerY)/M.x);
          // console.log(M.y, "*", (M.y-centerY)/M.x, "=", M.y*((M.y-centerY)/M.x));
          // console.log(V[v1].pos);console.log(V[v2].pos);
          // console.log(prevC);
          // console.log(prevC.len());
          // console.log("");
        }
      
        if (isEuclidean || prevC.len()>10000) {//mirror across a line
          for (var j=2; j<schlafliP; j++) {
            let newV=P[i].verts[j];
            let normalI=V[parentPoly.verts[(indexOfElement(parentPoly.verts, v1)-j+schlafliP)%schlafliP]].pos;//point to be mirrored, to get another position
      
            let s=V[v2].pos.sub(V[v1].pos);
            let k=V[v1].pos.sub(normalI);
      
            let invertedI=V[v1].pos.mult(2).sub(normalI).sub(s.mult(2*(k.x*s.x+k.y*s.y)/(s.x*s.x+s.y*s.y)));
            V[P[i].verts[j]].setPos(invertedI);
          }
        }
        else {//mirror with circle inversion
          for (var j=2; j<schlafliP; j++) {
            let newV=P[i].verts[j];
            let normalI=V[parentPoly.verts[(indexOfElement(parentPoly.verts, v1)-j+schlafliP)%schlafliP]].pos;//point to be mirrored, to get another position
            let prevCToNormalI=normalI.sub(prevC);
            let invertedI=prevC.add(prevCToNormalI.mult((newR/prevCToNormalI.len())**2));
      
            // console.log(invertedI);
            // context.strokeStyle=new Color(randRange(30, 256), randRange(30, 256), randRange(30, 256)).rgb();
            // // context.strokeStyle="rgb(200, 200, 200)";
            // context.lineWidth=1;
            // var prevCScreen=prevC.screen();
            // context.beginPath();
            // context.arc(prevCScreen.x, prevCScreen.y, newR*height/2, 0, TAU);
            // context.stroke();
      
            V[P[i].verts[j]].setPos(invertedI);
          }
        }
      
      }
      // /* DEBUG (dump graph info) */
      // for (var i=0; i<numVerts; i++) {
      //   console.log("V[" + i + "]");
      //   console.log("Adjacent vertexes:", V[i].next);
      //   console.log("Polygons:", V[i].polys);
      //   console.log(round(V[i].pos.x), round(V[i].pos.y));
      //   console.log("");
      // }
      // console.log(""); console.log("");
      // for (var i=0; i<numPolys; i++) {
      //   console.log("P[" + i + "]");
      //   console.log("Adjacent polygons:", P[i].next);
      //   console.log("Vertexes:", P[i].verts);
      //   console.log("");
      // }
      // console.log("numVerts", numVerts);
      // console.log("numPolys", numPolys);
            
      // setTilingTransforms();
    }
    
    function setDSFStuff() {//update the segment length and mirrorM, used when the schlafli symbol changes or the word mode is switched to // TODO: rename
      curDSF.updateSegmentLength();
      curDSF.updateMirrorM();
    }
    function DSFOperationNameFromString(str) {//given the shortened name of one operation, returns the full function name or undefined if it's invalid
      let res="";
      if (str.length==2 && (str[0]=="e" || str[0]=="s" || str[0]=="t") && (str[1]=="0" || str[1]=="1")) {
        res+={e:"extend", s:"swap", t:"trim"}[str[0]];
        res+=str[1];
        return res;
      }
      else if (str.length==1) {
        switch (str) {
          case "T":
            return "trimIfPossible";
          case "d":
            return "dual";
        }
      }
    }
    function getDSFFromOperations(ops) {//take a clean operation string and return the corresponding DSF or undefined if it's invalid
      let curSubstr="";
      let operations=[];
      for (var i = 0; i < ops.length; i++) {
        curSubstr+=ops[i];
        let curOp=DSFOperationNameFromString(curSubstr);
        if (typeof(curOp)!="undefined") {
          operations.push(curOp);
          curSubstr="";
        }
      }
      
      if (curSubstr.length==0) {//operation string was good, execute the operations
        let res=new DSF([0], []);
        for (var i = 0; i < operations.length; i++) {
          res=res[operations[i]]();
        }
        return res;
      }
    }
    function updateCurDSFOperations() {//set curDSF and corresponding values using the operation input string
      let cleanStr=dsfOperationsInput.value.replace(/\s/g, "");//remove all whitespace from the dsfOperationsInput
      if (cleanStr.length>1000) return;
      
      let newDSF=getDSFFromOperations(cleanStr);
      if (newDSF) {
        curDSF=newDSF;
        dsfOperationsInput.style.backgroundColor="";
      }
      else {//not successful, display as invalid
        dsfOperationsInput.style.backgroundColor="rgb(240, 80, 80)";
      }
      
      // console.log("Result: |w0|="+curDSF.w0.length+", |w1|="+curDSF.w1.length);
      w0LengthDisplay.innerHTML=curDSF.w0.length;
      w1LengthDisplay.innerHTML=curDSF.w1.length;
      
      setDSFStuff();
      clearAll();
    }
    
    // function restart() {
    //   clearAll();
    //
    //   // updateSchlafliSymbol();
    //
    //   // drawHypGrid();
    //   // drawFromCurDSF();
    // }
    
    function redrawBackground() {//clear the screen and draw whatever background elements have been selected. May draw curDSF or a simple hyperbolic grid
      context.clearRect(0, 0, canvas.width, height);
      if (initialDrawingReady) {
        // drawHypGrid();
        if (wordModeEnabled) {
          drawFromCurDSF();
        }
      }
    }
    
    function redrawAll() {//clear the screen, redraw the background and user drawn points
      redrawBackground();
      drawAllPoints();
    }
    
    function clearAll() {//clear the screen, redraw the background and clear user drawings
      redrawBackground();
      
      mousePositions=[];
      movements=[];
      movementColors=[];
      movementSizes=[];
      curMovement=-1;
      // autoGenerateVertexesGeometrically();
    }
    function resizeWithWait() {//call this in the resize event. on the event it sets a timer (minFramesSinceResize frames in length) after which it calls resize()
      if (framesSinceResize<minFramesSinceResize) {
        framesSinceResize++;
        window.requestAnimationFrame(resizeWithWait);
      }
      else {
        if (resizeRequested) {
          resize();
          resizeRequested=false;
        }
        framesSinceResize=0;
      }
    }
    function resize() {//resize the canvas, change the height variable, and redrawAll()
      canvas.width=changingCanvas.width=window.innerWidth;
      height=canvas.height=changingCanvas.height=window.innerHeight;
      redrawAll();
    }
        
    
    updateSchlafliSymbol();
    generateHyperbolicGraph();
    
    setWordModeEnabled(true);
    // setWordModeEnabled(false);
    initialDrawingReady=true;
    
    resize();
    update();

    // console.log("%cTest", "font-weight:bold; color:lime; font-size:160%");
    // updateMirrorAngle(0);
    // console.log(tilingTransforms);
    // tilingTypeName="none"; setTilingTransforms(); clearAll();
    
    // let numTestOps=5;
    // for (var i = 0; i < 1<<numTestOps; i++) {
    //   let binStr="";
    //   let opStr="e1";
    //   for (var j = 0; j < numTestOps; j++) {
    //     if (1<<j & i) {
    //       binStr+="1";
    //       opStr+="e1s1";
    //     }
    //     else {
    //       binStr+="0";
    //       opStr+="e0s1";
    //     }
    //   }
    //   // console.log(binStr);
    //   console.log(opStr);
    //   let dsf=getDSFFromOperations(opStr);
    //   // console.log(dsf);
    //
    //   let countW0=[0,0,0,0];
    //   for (var k = 0; k < dsf.w0.length; k++) {
    //     countW0[mod(dsf.w0[k], schlafliP)]++;
    //   }
    //   let countEdge=countW0.slice();//copy countW0
    //   for (var k = 0; k < dsf.w1.length; k++) {
    //     countEdge[mod(dsf.w1[k], schlafliP)]++;
    //   }
    //   // let edgeVec=dsf.getEdgeVector();
    //   // console.log(countW0);
    //   let w0Vec=new Vec2(countW0[0]-countW0[2], countW0[1]-countW0[3]);
    //   let edgeVec=new Vec2(countEdge[0]-countEdge[2], countEdge[1]-countEdge[3]);
    //   // let mirrorSlope=dsf.getMirrorSlope();
    //   // console.log("w0", [w0X, w0Y]);
    //
    //   // let mirrorSlope=Math.tan(hypSASGetAngleAtFirstSide(centerToVertexHyp, PI/schlafliQ+globalEdgeAngleOffset-w0Vec.ang(), runningLen)/2);;
    //   // let mirrorSlope=Math.tan(hypSASGetAngleAtFirstSide(centerToVertexHyp, PI/schlafliQ+edgeVec.ang()-w0Vec.ang(), edgeVec.len())/2);
    //   // let mirrorSlope=Math.tan(( w0Vec.add(new Vec2(-Math.cos(edgeVec.ang()), 0)).ang() )/2);
    //   // console.log(w0Vec.ang());//always 0
    //   // console.log();
    //   let mirrorSlope=Math.tan(HPI/2-edgeVec.ang());
    //   console.log("slope", mirrorSlope);
    // }
    
    function logOpsInfo(str) {
      let dsf=getDSFFromOperations(str);
      let u0v0=dsf.getU0V0();
      let u1v1=dsf.getU1V1();
      console.log("0:", u0v0.u, u0v0.v);
      console.log("1:", u1v1.u, u1v1.v);
    }

    function mouseUp(){
      if (mouseDown) {
        mouseDown=false;
        movementColors.push(fillColorWithErase);
        movementSizes.push(drawSize);
        fillColorWithErase=fillColor;
        movements.push(mousePositions.length);
      }
    }
    function selectFillColor(c) {
      fillColor=fillColorWithErase=c;
    }

    window.addEventListener("mousemove", function() {
      // if (!paused) {
        // mousePos.x=event.clientX;
        // mousePos.y=event.clientY;
        mousePos=new Vec2(
          (event.clientX+mousePos.x*mouseSlowingFactor)/(mouseSlowingFactor+1),
          (event.clientY+mousePos.y*mouseSlowingFactor)/(mouseSlowingFactor+1)
        );
      // }
    });
    changingCanvas.oncontextmenu = function() { return false; }//so that right clicking doesn't open a menu
    changingCanvas.onmousedown = function() {
      mouseDown=true;
      if (event.buttons==1) {//RMB, draw
        fillColorWithErase=fillColor;
      }
      else if (event.buttons==2) {//LMB, erase
        fillColorWithErase=BGColor;
      }
      else {//multiple buttons or a weird button has been pressed, pretend the mouse was released
        mouseUp();
        return;
      }
      curMovement++;
    }
    changingCanvas.onmouseup = mouseUp;

    window.addEventListener("keyup", function() {
      var curKey=event.keyCode;
      keys[curKey]=false;
      // console.log(keys);
    });
    window.addEventListener("keydown",function(){
      var curKey=event.keyCode;
      keys[curKey]=true;
      // console.log(keys);
      // console.log(curKey);
      switch (curKey) {
        case 32://space - pause
          paused=!paused;
          if (paused) {
            // console.log("Paused");
            dropBtn.innerHTML="⏸";
            changingCanvas.style.display="none";
          }
          else {
            // console.log("Unpaused");
            update();
            dropBtn.innerHTML="";
            changingCanvas.style.display="";
          }
          break;
        // case 68://d - draw hyperbolic grid // TODO: not really useful
        //   drawHypGrid();
        //   break;
        case 82://r - clear all
          clearAll();
          break;
        case 90://z - undo
          if (curMovement>=0) {
            mouseUp();
            curMovement--;
            let lastMovementVal=movements.pop();
            movementColors.pop();
            movementSizes.pop();
            let curMovementVal=movements.length==0 ? 0 : movements[movements.length-1];
            mousePositions.splice(curMovementVal, lastMovementVal-curMovementVal);
          };
          redrawAll();
          break;
      }
    });
    window.addEventListener("resize", function() {
      if (!resizeRequested) {
        resizeRequested=true;
        resizeWithWait();
      }
    });
  </script>
</body>
</html>
