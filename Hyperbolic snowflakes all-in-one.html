<!DOCTYPE html>
<!-- TODO: elaborate notes -->
<!--
  This code generates double square tiles, tilable snowflakes and allows drawing of symmetrical tilable shapes

  ComProp is short for the article "Combinatorial properties of double square tiles"

 -->
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>Hyperbolic Snowflakes</title>
  <style media="screen">
    /* TODO: fix unit clusterfuck (vh, rem, px) */

    body {
      /* background-color: rgb(10,15,30); */
      background-color: rgb(0,0,0);
      /* color: rgb(200, 200, 200); */
      /* color: rgb(10, 10, 10); */
      font-family: sans-serif;
      font-size: 2.5vh;  /* TODO: better with it? */
      overflow: hidden;
    }
    canvas {
      position: absolute;
      left: 0;
      top: 0;
    }
    div span {
      color: white;
      /* padding: 5px 15px; */
      font-size: 16px;
      min-width: 90px;
      min-height: 15px;
      text-decoration: none;
      /* display: block; */
    }

    button {
      user-select: none;
    }
    .noSelect {
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
      -khtml-user-select: none; /* Konqueror HTML */
      -moz-user-select: none; /* Old versions of Firefox */
      -ms-user-select: none; /* Internet Explorer/Edge */
      user-select: none; /* Non-prefixed version, currently
      supported by Chrome, Edge, Opera and Firefox */
    }



    .drop-btn {/* Style The Dropdown Button */
      background-color: #237;
      /* background-color: #0000; */
      /* color: white; */
      /* padding: 0; */
      /* font-size: 16px; */
      width: 30px;
      height: 30px;
      border: none;
      cursor: pointer;
      position: absolute;
      left: 0;
      top: 0;
      padding: 0;
      /* font-size: 30px; */
      font-size: 20px;
    }

    .dropdown {/* The container div - needed to position the dropdown content */
      position: absolute;
      left: 10px;
      top: 10px;
      display: inline-block;
      background-color: #2228;
      /* outline: 2px solid black; */
    }

    .dropdown-content {/* Dropdown Content (Hidden by Default) */
      display: none;
      /* display: inline-block; */ /* uncomment this to make the dropdown content always visible */
      /* position: absolute; */
      /* background-color: #237; */
      /* box-shadow: 0px 8px 16px 0px #0004); */
      /* padding: 6px 0px; */
      z-index: 1;
      vertical-align: top;
    }

    /* .dropdown-content div {/* Links inside the dropdown */

    /*.dropdown-content div:hover {background-color: #335}/* Change color of dropdown links on hover */


    .dropdown:hover .drop-btn {/* Hide the dropdown button while dropdown is being hovered */
      display: none;
    }
    .dropdown:hover .dropdown-content {/* Display the dropdown content while the dropdown is being hovered */
      display: inline-block;
    }

    .simple-button {
      background-color: #237;
    }
    .simple-button:hover {
      background-color: #124;
    }

    #draw-size-container {
      padding: 0;
      background-color: transparent;
    }
    .draw-size-option {
      padding: 5px 10px;
    }

    #mirror-angle-setting-container {
      margin-bottom: 1.5%;
    }

    .mirror-angle-input-option {
      /* outline: 1px solid black; */
      border-radius: 6px 6px 0 0;
      margin-right: 1px;
      padding: 5px 3.5% 1.5% 3.5%;
    }

    .mirror-angle-number-input {
      width: 30%;
      margin-left: 3px;
      margin-right: 3px;
    }
    .mirror-angle-number-input-container {
      /* outline: 2px dashed yellow; */
      /* width: 200%; */ /* TODO: this shit doesn't work */
      display: none;
      background-color: #237;
      border-radius: 0 0px 6px 6px;
      padding: 5px 15px;
    }

    #mirror-angle-value-container {
      color: white;
      /* padding: 15px 5px; */
      /* margin-top: 4px; */
      margin-bottom: 2%;
    }

    #tiling-type-input {
      color: white;
    }

    #auto-generate-valid-snowflake {
      border: 1px solid #777;
      border-radius: 3px;
      background-color: #eee;
      color: black;
      padding: 1% 2%;
    }
    #auto-generate-valid-snowflake:disabled,
    #auto-generate-valid-snowflake[disabled] {
      /* border-color: #777;
      background-color: #ddd;
      color: #aaa; */
      opacity: 0.5;
    }
    #auto-generate-valid-snowflake:hover {
      background-color: #ddd;
    }
    #auto-generate-valid-snowflake:active {
      background-color: #ccc;
      padding: 1.3% 2% 0.7% 2%;/* TODO: probably not a good idea */
      /* border-width: 3px; */
    }


    #use-mirrors-button {
      padding: 0.8% 4%;
      color: white;
      border-radius: 0.25rem;
      text-align: center;
      width: 25%;
    }

    .color-select-option {
      width: 13vw;
      height: 3.5vh;
    }



    .uiContainer {
      text-align: right;

      /* font-family: cursive; */
      /* position: absolute; */
      left: 1.6vh;
      top: 1.6vh;
      z-index: 2;
      background-color: hsl(0,0%,30%);
      padding: 1vh;
      border-radius: 1vh;
      line-height: 3.5vh;
      overflow: auto;
      margin-bottom: 1rem;
      color: rgb(200, 200, 200);
    }
    .uiSubContainer {
      text-align: left;
      background-color: hsl(0,0%,85%);
      padding: 0.6vh;
      margin: 0.3vh;
      border-radius: 0.6vh;
      color: rgb(10, 10, 10);
    }

    .gameSettingsNumbers {
      width: 4.5vh;
      /* background-color: hsl(0,0%,75%); */
      background-color: inherit;
      border-radius: 0.4vh;
      border: 1px solid gray;
    }
    .inlineNumber {
      display: inline;
    }
    #schlafli-input-container {
       padding-bottom:3px;
       padding-top:3px;
       color: black;
    }

  </style>
</head>
<body>
  <canvas id="canvas" width="300" height="300"></canvas>
  <canvas id="changing-canvas" width="300" height="300"></canvas>

  <div class="dropdown">
    <button id="drop-btn" class="drop-btn"></button>



    <div class="dropdown-content" id="color-select-dropdown"></div>
    <!-- <div class="dropdown-content" style="width:40vw"> -->
    <div class="dropdown-content">
      <div id="draw-size-container" style="margin-bottom: 1.8vh;"><!-- pen size -->
        <span class="simple-button draw-size-option" onclick="drawSize=1">1px</span>
        <span class="simple-button draw-size-option" onclick="drawSize=3">3px</span>
        <span class="simple-button draw-size-option" onclick="drawSize=10">10px</span>
        <span class="simple-button draw-size-option" onclick="drawSize=30">30px</span>
      </div>
      <span id="use-mirrors-button" style="display:inline-block" onclick="invertUseMirrors()"></span>
      <span id="word-mode-button" style="display:inline-block" onclick="invertWordModeEnabled()"></span>
      <hr>
      <div id="word-mode-container">
      </div>
      <div id="drawing-mode-container">
        <div id="mirror-angle-container">
          <div id="mirror-angle-setting-container" style="padding-left: 0; padding-bottom:5px; padding-top: 2%"></div><!-- which mirror angle input setting to use (slope, deg, rad...) -->
          <div id="mirror-angle-value-container" style="padding-left: 0"></div>
        </div>
        <button style="font-size:16px" id="auto-generate-valid-snowflake" onclick="autoGenerateVerticesGeometrically()">Auto-generate geometrically</button>
        <form style="margin-bottom: 3%" id="tiling-type-input" onchange="updateTilingType()"></form>
      </div>




      <hr>

      <div class="dropdown-content uiContainer">
        <div class="uiSubContainer">
          <span id="schlafli-input-container"><b>{<input class="gameSettingsNumbers" type="number" id="schlafliP" name="schlafliP" min="3" max="30">; <input class="gameSettingsNumbers" type="number" id="schlafliQ" name="schlafliQ" min="3" max="30">}</b></span> grid<br>
          <button onclick="updateSchlafliSymbol()"><b>Go</b></button>
        </div>
      </div>
    </div>
  </div>
  
  <script type="text/javascript">
    "use strict";
    function rand(max=1) {
      return Math.random()*max;
    }
    function rand0(max=1) {
      return (Math.random()-0.5)*max;
    }
    function randInt(max=2) {
      return Math.floor(Math.random()*max);
    }
    function randProb(p=0.5) {
      return p>Math.random();
    }
    function randRange(a, b) {
      return Math.random()*(b-a)+a;
    }
    function clamp(num, val=1) {//num to clamp, special value
      return 1-(val/(num+val));
    }
    function colorLerp(n1, n2, x=0.5) {
      return n2.sub(n1).mult(x).add(n1);
    }
    function cutoff(x, min, max) {
      if (min!=undefined && x<min) {
        return min;
      }
      if (max!=undefined && x>max) {
        return max;
      }
      return x;
    }
    function closenessPenalty(x, coefficient) { //what number to divide x by so it doesn't reach 1
      return 1-coefficient-coefficient/(x-1);
    }
    function round(v, p=2) {
      return Math.round(v*10**p+Number.EPSILON)/10**p;
    }
    function lerp(x, v1, v2) {
      return x*(v2-v1)+v1;
    }
    function map(x, a1, a2, b1, b2) {
      return (x-a1)/(a2-a1)*(b2-b1)+b1;
    }
    function arrayContains(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i]==val) return true;
      }
      return false;
    }
    function indexOfElement(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i]==val) return i;
      }
      // return false;// TODO: is this fine?
    }
    function arraysShallowEqual(a, b) {
      var i = a.length;
      if (i != b.length) return false;
      while (i--) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    };
    function arrayPush(arr, el) {//pushes el to arr and returns arr
      arr.push(el);
      return arr;
    }
    function mod(v, m) {//%, but works properly with negative numbers
      return (v%m+m)%m;
    }

    /* TODO:
      a bunch of attribution is still needed
      
      replace a bunch of 0.001 epsilons
      fix having to rotate the board slightly? (see other to-dos)

      word ui
      just drawing previews is demanding? (canvas transformations might help???)
      detailed drawing mode (zoom in on one fundamental triangle)
      better, more efficient undo (could fairly easily be much more efficient one level deep)
      better UI
      canvas.width etc shorten to width or w
      find all TO-DOs
      better resizing
      erase pointless commented code
      change page title?
      refactor all the things
      replace var with let?
    */


    var canvas=document.getElementById("canvas");
      var context=canvas.getContext("2d");
      
      var changingCanvas=document.getElementById("changing-canvas");
      var changingContext=changingCanvas.getContext("2d");
      var dropBtn=document.getElementById("drop-btn");
      var useMirrorsButton=document.getElementById("use-mirrors-button");
      var autoGenerateButton=document.getElementById("auto-generate-valid-snowflake");
      var mirrorAngleContainer=document.getElementById("mirror-angle-container");
      var schlafliInputContainer=document.getElementById("schlafli-input-container");
      
      var wordModeButton=document.getElementById("word-mode-button");
      var wordModeContainer=document.getElementById("word-mode-container");
      var drawingModeContainer=document.getElementById("drawing-mode-container");
      
      const TAU=2*Math.PI;
        const PI=Math.PI;
        const HPI=Math.PI/2;
        const PHI=(Math.sqrt(5)+1)/2;
        const ROOT2=Math.sqrt(2);
        const ROOT3=Math.sqrt(3);
        const HALFROOT3=Math.sqrt(3)/2;
      var paused=false;
      var frameSkip= 1 ;// TODO: what's the right value? (10 in hyp, 1 in snow?)
      // var frameSkip= 20 ;
      var fReqs=frameSkip;
      var colorChangeSteps=0;
      var keys=[];
      var mousePos=new Vec2();
      var mouseDown=false;
      var height=100;// TODO: use this instead of canvas.height, similarly do for width (or delete this)
      
      
      var mousePositions=[];//mouse locations as Vec2 for individual points
      var movements=[];      //
      var movementColors=[]; //
      var movementSizes=[];  // TODO: make these 3 into an object array
      var curMovement=-1;//index of which movement (in the movements array) is currently happening or which has last been finished
      // var globalScaling=0.5;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      var globalScaling=0.8;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      // var globalScaling=1;//applies to user drawing (drawPointAtPosition) and drawToWholeScreen
      var DSFGridScaling=0.85;//applies to generateDSFGrid
      const minFramesSinceResize=10;//if the window is being constantly resized (slow dragging), resize the canvas every minFramesSinceResize frames
      var framesSinceResize=minFramesSinceResize;
      var resizeRequested=true;//has the window been resized while the canvas hasn't yet?
      const mouseSlowingFactor=1.5;//0-infinity, sets how much mouse movement is smoothed out, see equation in mousemove event
      var drawSize=1;// TODO: should be relative to some unit, otherwise scaling messes up filled regions
      
      var schlafliSymbol=[6, 3];
      // var schlafliSymbol=[3, 6];
      // var schlafliSymbol=[4, 6];
      // var schlafliSymbol=[6, 4];
      // var schlafliSymbol=[5, 4];
      // var schlafliSymbol=[4, 4];
      // var schlafliSymbol=[4, 5];
      // var schlafliSymbol=[7, 3];
      // var schlafliSymbol=[10, 3];
      
      var schlafliP=schlafliSymbol[0];
      var schlafliQ=schlafliSymbol[1];
      
      // var tilingTypeName="none";
      // var tilingTypeName="hypTest";
      var tilingTypeName="regular using schlafli";
      
      var tilingTypes=[["none"], ["hypTest"], ["regular using schlafli"]];
      // var tilingTypeName=tilingTypes[tilingTypeIndex][0];
      
      // var tilingTypeName;
      var tilingTypeIndex;
      for (var i = 0; i < tilingTypes.length; i++) {
        let t=tilingTypes[i];//the current tiling type
        document.getElementById("tiling-type-input").innerHTML+="<input id='tiling-type-"+i+"' type='radio' name='tiling-type' value='"+t[0]+"'><label for='tiling-type-"+i+"'>"+t[0]+"</label>";// TODO: too long
        
        if (tilingTypes[i][0]==tilingTypeName) {//set tilingTypeIndex
          tilingTypeIndex=i;
        }
      }
      document.getElementById("tiling-type-"+tilingTypeIndex).checked=true;
      
      var initialDrawingReady=false;
      
      var useMirrors;//the tile is either mirror symmetrical (true) or chiral (false)
      function setUseMirrors(u) {
        if (useMirrors!==u) {
          useMirrors=u;
          if (useMirrors) {
            useMirrorsButton.style.backgroundColor="#16f";
            useMirrorsButton.innerHTML="Dihedral";
            mirrorAngleContainer.style.opacity=1;
          }
          else {
            useMirrorsButton.style.backgroundColor="#666";
            useMirrorsButton.innerHTML="Chiral";
            mirrorAngleContainer.style.opacity=0.5;
          }
          setInTileTransforms();
          clearAll();
          updateAutoGenerateButton();
        }
      }
      function invertUseMirrors() {
        setUseMirrors(!useMirrors);
      }
      setUseMirrors(true);
      
      var wordModeEnabled;//the tile is either mirror symmetrical (true) or chiral (false)
      function setWordModeEnabled(u) {
        if (wordModeEnabled!==u) {
          wordModeEnabled=u;
          if (wordModeEnabled) {
            wordModeButton.style.backgroundColor="#16f";
            wordModeButton.innerHTML="Word mode";
            wordModeContainer.style.visibility="visible";
            drawingModeContainer.style.visibility="hidden";
            // setTilingTransforms("regular using schlafli");// TODO: would modifying the function and using this be better (otherwise i need an extra line to change tilingTypeName)
            tilingTypeName="regular using schlafli";
            setTilingTransforms();
            // if (initialDrawingReady) {
              setDSFStuff();
            // }
          }
          else {
            wordModeButton.style.backgroundColor="#666";
            wordModeButton.innerHTML="Drawing mode";
            wordModeContainer.style.visibility="hidden";
            drawingModeContainer.style.visibility="visible";
            // setTilingTransforms("regular using schlafli");
            setTilingTransforms();
            // if (initialDrawingReady) {
              updateMirrorAngle();
            // }
          }
          updateAutoGenerateButton();
          clearAll();
        }
      }
      function invertWordModeEnabled() {
        setWordModeEnabled(!wordModeEnabled);
      }
      
      var curMirrorAngleInput=0;
      var mirrorAngleInputOptionsArr=[//[symbol in selection tab, function to make the input into a slope, text before input box, text after input box]
        ["k=√3/x", function(x){ return ROOT3/x; }, "Slope=√3/", ""],
        ["k=x", function(x){ return x; }, "Slope=", ""],
        ["θ=x <i>rad</i>", function(x){ return Math.tan(x); }, "Angle=", "<i>rad</i>"],
        ["θ=x°", function(x){ return Math.tan(x/360*TAU); }, "Angle=", "°"]
      ]
      function setCurMirrorAngleInput(curInput=0) {
        curMirrorAngleInput=curInput;
        for (var i = 0; i < mirrorAngleInputOptionsArr.length; i++) {
          document.getElementById("mirror-angle-number-input-container-"+i).style.display="none";
          document.getElementById("mirror-angle-input-option-"+i).style.backgroundColor="#124";
        }
        document.getElementById("mirror-angle-number-input-container-"+curMirrorAngleInput).style.display="inline";
        document.getElementById("mirror-angle-input-option-"+curMirrorAngleInput).style.backgroundColor="#237";
        updateMirrorAngle();
      }
      for (var i = 0; i < mirrorAngleInputOptionsArr.length; i++) {
        // TODO: adding big elements through js, not pretty
        //add tabs which can be clicked to select the way the mirror angle is inputted
        document.getElementById("mirror-angle-setting-container").innerHTML+="<span class='mirror-angle-input-option' id='mirror-angle-input-option-"+i+"' onclick='setCurMirrorAngleInput("+i+")'>"+mirrorAngleInputOptionsArr[i][0]+"</span>";
        //add containers with a number input and a description of how it is turned into the mirror angle. They're on top of eachother and not displayed by default
        document.getElementById("mirror-angle-value-container").innerHTML+="<div class='mirror-angle-number-input-container' id='mirror-angle-number-input-container-"+i+"'>"+mirrorAngleInputOptionsArr[i][2]+"<input class='mirror-angle-number-input' id='mirror-angle-number-input-"+i+"' type='number' step='any' value='15' onchange='updateMirrorAngle()'>"+mirrorAngleInputOptionsArr[i][3]+"<br>";// TODO: better default values
      }
      setCurMirrorAngleInput();
      
      function canAutoGenerateGeometrically() {
        // return useMirrors && (// TODO: can i use this?
        //   (schlafliP==6 && schlafliQ==3) ||
        //   (schlafliP==4 && schlafliQ==4)
        // );
        return schlafliP==6 && schlafliQ==3 && useMirrors && tilingTypeName=="regular using schlafli";
      }
      function updateAutoGenerateButton() {//update whether the tiling auto-generation button can be clicked or is greyed out
        let clickability=canAutoGenerateGeometrically();
        autoGenerateButton.disabled=!clickability;
      }
      
      var P=[];//Polygons array
        var V=[];//Vertices array
        const radius=1;//has to be 1
        var numPolys=0;
        var numVerts=0;
        document.getElementById("schlafliP").value=schlafliP;// TODO: objects instead of calling getElementByIds?
        document.getElementById("schlafliQ").value=schlafliQ;
        var numTakenVerts=0;
        var lastClickTookPolygon=false;
        var isEuclidean=false;
        
        var edgeLengthHyp;
        var centerToEdgeMidpointEuc;
        var centerToEdgeMidpointHyp;
        var centerToVertexEuc;//hyp distance from the center of a tile to its vertex, for the tiling given by schlafliSymbol
        var centerToVertexHyp;
        
        var hypPolyVertRadius= 0.15 ;
        var hypPolyEdgeWidth= 0.03 ;
        
        var globalEdgeAngleOffset;
        
        function distortion(vec) {
          return vec;//do nothing function
          // return new Vec2(Math.sin(vec.x*HPI), Math.sin(vec.y*HPI));
          // let dist=vec.len();
          // return vec.mult( Math.sin(dist*HPI) /dist);
          // return vec.mult( Math.asin(dist)/HPI /dist);
        }
    

    function wordPeriodLen(w) {
      let period=1;
      let periodFound=false;
      for (; period < w.length+1; period++) {
        periodFound=true;
        for (var j = period; j < w.length; j++) {
          if (w[j-period]!=w[j]) {
            periodFound=false;
            break;
          }
        }
        if (periodFound) {
          break;
        }
      }
      return period;
    }
    function wordUV(w) {// TODO: delete after making analogous method of DSF
      let period=wordPeriodLen(w);

      let uLen=w.length % period;
      let newW=w.slice();
      let u=newW.splice(0, uLen);
      let v=newW.slice(0, period-uLen);

      return {u: u, v: v};
    }
    function wordRho(r, w) {//rotate the word w by r (add r to each element, modulo the schlafliP)
      let res=[];
      for (var i = 0; i < w.length; i++) {
        // res[i]=((w[i]+r)%schlafliP+schlafliP)%schlafliP;
        res[i]=w[i]+r;// TODO: is it really this simple to make the tiles work with negative numbers?! this will have to be noted
      }
      return res;
    }
    function wordSplitUVAndVU(uv, vu) {//input: uv and vu; output: u and v (// TODO: only hopefully, need to check better)
      if (uv.length==vu.length) {
        let d=uv.length;
        let i=0;
        for (; i < d; i++) {
          let done=true;
          for (var j = i; j < d; j++) {
            if (uv[j-i]!=vu[j]) {
              done=false;
              break;
            }
          }
          if (done) break;
        }
        let u=uv.slice(0, d-i);
        let v=vu.slice(0, i);
        if (!arraysShallowEqual(u.slice().concat(v), uv) || !arraysShallowEqual(v.slice().concat(u), vu)) {
          console.warn("wordSplitUVAndVU failed");
          console.log("i", i, "uv", uv, "vu", vu);
          console.log("u", u, "v", v);
        }
        return {u:u, v:v};
      }
      alert("alert005 wordSplitUVAndVU bad input");
      return {u:[], v:[]};
    }
    function DSF(w0, w1, operatorTrace=[]) {//class for a modification of a double square factorization (restricted with symmetry but generalized with different tilings TODO: it's not really DSF, but some modification/generalization of it, i should rename the class). most of the algorithms here are from ComProp
      // TODO: this is a wall of code
      // TODO: add a schlafliP property (because maybe i want to generate and display tiles that aren't selected for user drawing)
      this.w0=w0.slice();
      this.w1=w1.slice();
      this.segmentLength=1;
      this.operatorTrace=operatorTrace;
      this.getWord=function(i) {// TODO: untested and unused
        if ((i%2+2)%2==0) {
          return wordRho(i/2, w0);
        }
        else if ((i%2+2)%2==1) {
          return wordRho((i-1)/2, w1);
        }
        else {
          alert("alert004 i isn't an integer");
          return [];
        }
      }
      this.getEdgeWord=function() {//get w0 concat w1  (the edge)
        return w0.concat(this.w1);
      }
      this.getBoundaryWord=function() {//get w0 concat w1 concat wordRho(1, w0) concat wordRho(1, w1) ...  (the whole boundary)
        let edgeWord=this.getEdgeWord();
        let res=edgeWord.slice();//copy of edgeWord
        for (var i = 1; i < schlafliP; i++) {
          for (var j = 0; j < edgeWord.length; j++) {// TODO: use wordRho instead of extra loop
            res.push((edgeWord[j]+i)%schlafliP);
          }
        }
        return res;
      }
      this.getEdgeVector=function() {//get the displacement vector of the path of one edge (assuming 0 means rightwards and every segment is of unit length)
        let edgeVector=new Vec2();
        let edgeWord=this.getEdgeWord();
        for (var i = 0; i < edgeWord.length; i++) {
          edgeVector=new Vec2(edgeVector.x+Math.cos(edgeWord[i]*TAU/schlafliP), edgeVector.y-Math.sin(edgeWord[i]*TAU/schlafliP));
        }
        return edgeVector;
      }
      this.getMaxDistFromCenter=function() {//distance from the farthest vertex to the center of the tile
        let edgeVec=this.getEdgeVector();
        let center=edgeVec.rotate(HPI-PI/schlafliP).mult(1/(2*Math.sin(PI/schlafliP)));//vector to the center of the tile
        // console.log(edgeVec, center);
        // console.log(edgeVec.len()/center.len());
        // console.log(center.ang()-edgeVec.ang());
        let edgeWord=this.getEdgeWord();
        let curPos=new Vec2();
        let maxSqDist=0;
        for (var i = 0; i < edgeWord.length; i++) {
          curPos=new Vec2(curPos.x+Math.cos(edgeWord[i]*TAU/schlafliP), curPos.y-Math.sin(edgeWord[i]*TAU/schlafliP));
          let curSqDist=curPos.sqDist(center);
          if (maxSqDist<curSqDist) maxSqDist=curSqDist;
        }
        return Math.sqrt(maxSqDist);
      }
      this.len=function() {
        return 6*(this.w0.length+this.w1.length);
      }
      
      this.getU0V0=function() {// TODO: basically like getu1v1, simplify!
        // if (this.w1.length!=0) {// TODO:
        let w1=this.w1.slice();
        let wNegative1=wordRho(-1, w1);
        let uv=w1.slice().reverse().concat(wNegative1);
        let vu=w1.slice().concat(wNegative1.slice().reverse());
        
        let fromSplitFunc=wordSplitUVAndVU(uv, vu);
        
        if (!arraysShallowEqual(fromSplitFunc.u.slice().concat(fromSplitFunc.v), uv) || !arraysShallowEqual(fromSplitFunc.v.slice().concat(fromSplitFunc.u), vu)) {// TODO:
          console.log("");
          console.warn("alert002 getU0V0");
          // alert("alert002 getU0V0");
          
          let fromFunc=wordUV(this.w0);
          let uvGGG=wordRho(1, this.w0).reverse().concat(this.w0);
          let vuGGG=wordRho(1, this.w0).concat(this.w0.slice().reverse());
          // console.log("check in getU0V0", fromFunc.u.slice().concat(fromFunc.v), uvGGG, "and", fromFunc.v.slice().concat(fromFunc.u), vuGGG);
          if (!arraysShallowEqual(fromFunc.u.slice().concat(fromFunc.v), uvGGG) || !arraysShallowEqual(fromFunc.v.slice().concat(fromFunc.u), vuGGG)) {// TODO:
            console.log("");
            console.warn("alert003 getU0V0");
            // alert("alert002 getU1V1");
          }
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {// TODO: not a good check
            return fromFunc;
          }
          return fromFunc;
        }
        // console.log("i", i, "u0v0", uv, "v0u0", vu);
        return {u:fromSplitFunc.u, v:fromSplitFunc.v};
      }
      this.getU1V1=function() {
        // if (this.w1.length!=0) {// TODO:
        let w0=this.w0.slice();
        let w2=wordRho(1, w0);
        let uv=w2.slice().reverse().concat(w0);
        let vu=w2.slice().concat(w0.slice().reverse());
        
        let fromSplitFunc=wordSplitUVAndVU(uv, vu);
        
        if (!arraysShallowEqual(fromSplitFunc.u.slice().concat(fromSplitFunc.v), uv) || !arraysShallowEqual(fromSplitFunc.v.slice().concat(fromSplitFunc.u), vu)) {// TODO:
          console.log("");
          console.warn("alert002 getU1V1");
          // alert("alert002 getU1V1");
          
          let fromFunc=wordUV(this.w1);
          let uvGGG=wordRho(1, this.w0).reverse().concat(this.w0);
          let vuGGG=wordRho(1, this.w0).concat(this.w0.slice().reverse());
          // console.log("check in getU1V1", fromFunc.u.slice().concat(fromFunc.v), uvGGG, "and", fromFunc.v.slice().concat(fromFunc.u), vuGGG);
          if (!arraysShallowEqual(fromFunc.u.slice().concat(fromFunc.v), uvGGG) || !arraysShallowEqual(fromFunc.v.slice().concat(fromFunc.u), vuGGG)) {// TODO:
            console.log("");
            console.warn("alert003 getU1V1");
            // alert("alert002 getU1V1");
          }
          // console.log(fromFunc);
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {// TODO: not a good check
            return fromFunc;
          }
          return fromFunc;
        }
        // console.log("i", i, "u1v1", uv, "v1u1", vu);
        return {u:fromSplitFunc.u, v:fromSplitFunc.v};
      }
      this.getU0ConcatV0=function() {
        if (this.w1.length!=0) {
          return this.w1.slice().reverse().concat(wordRho(-1, this.w1));
        }
        else {
          let fromFunc=wordUV(this.w0);
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {
            return fromFunc.u.concat(fromFunc.v);
          }
          else {
            alert("alert005 kinda bad but mainly bad input");
            console.log("alert005 kinda bad but mainly bad input");
            return [];
          }
        }
        
        // let fromFunc=wordUV(this.w0);
        // // console.log(fromFunc);
        // if (fromFunc.u.length>0 && fromFunc.v.length>0) {
        //   return fromFunc.u.concat(fromFunc.v);
        // }
        // else if (this.w1.length!=0) {
        //   return this.w1.slice().reverse().concat(wordRho(-1, this.w1));
        // }
        // // else {// TODO: i think this is only in the case of a hexagon
        // //   console.log("vvvv");
        // //   return wordRho(1, this.w1).concat(this.w1);
        // // }
        // console.log("bad");// TODO: temporary
        // return fromFunc;// TODO: temporary
      }
      this.getU1ConcatV1=function() {
        if (this.w0.length!=0) {
          return wordRho(1, this.w0).reverse().concat(this.w0);
        }
        else {
          let fromFunc=wordUV(this.w1);
          if (fromFunc.u.length>0 && fromFunc.v.length>0) {// TODO: ????? is this a good check? i don't think so
            return fromFunc.u.concat(fromFunc.v);
          }
          else {
            alert("alert005 kinda bad but mainly bad input");
            console.log("alert005 kinda bad but mainly bad input");
            return [];
          }
        }

        // let fromFunc=wordUV(this.w1);
        // // console.log(fromFunc);
        // if (fromFunc.u.length>0 && fromFunc.v.length>0) {
        //   return fromFunc.u.concat(fromFunc.v);
        // }
        // else if (this.w0.length!=0) {
        //   return wordRho(1, this.w0).reverse().concat(this.w0);
        // }
        // // else {// TODO: i think this is only in the case of a hexagon
        // //   console.log("vvvv");
        // //   return this.w0.slice().concat(wordRho(1, this.w0));
        // // }
        // console.log("bad");// TODO: temporary
        // return fromFunc;// TODO: temporary
        //
        // // let fromFunc=wordUV(this.w1);
        // // console.log(fromFunc);
        // // if (fromFunc.u.length>0 && fromFunc.v.length>0) {
        // //   console.log("|u1|, |v1| > 0");
        // //   return fromFunc.u.concat(fromFunc.v);
        // // }
        // // else {
        // //   console.log("|u1| or |v1| == 0");
        // //   if (this.w0.length!=0) {
        // //     console.log("|w0| > 0");
        // //     return wordRho(1, this.w0).reverse().concat(this.w0);
        // //   }
        // //   else {
        // //     console.log("|w0| == 0");
        // //   }
        // // }
        // // // else {// TODO: i think this is only in the case of a hexagon
        // // //   console.log("vvvv");
        // // //   return this.w0.slice().concat(wordRho(1, this.w0));
        // // // }
        // // console.log("bad");// TODO: temporary
        // // return fromFunc;// TODO: temporary
      }
      
      this.trim0=function() {
        let newW0=this.w0.slice(0, -wordPeriodLen(this.w0));// TODO: will this always work?
        return new DSF(newW0, this.w1, arrayPush(this.operatorTrace.slice(), "trim0"));
      }
      this.trim1=function() {
        let newW1=this.w1.slice(0, -wordPeriodLen(this.w1));
        return new DSF(this.w0, newW1, arrayPush(this.operatorTrace.slice(), "trim1"));
      }
      this.trimIfPossible=function() {
        if (this.w0.length>2*this.w1.length && this.w1.length>0) {
          return this.trim0();
        }
        else if (this.w1.length>2*this.w0.length && this.w0.length>0) {
          return this.trim1();
        }
        else {
          return this;
        }
      }
      this.swap0=function() {
        let newW0=this.w0.slice().reverse();
        let uv=this.getU1V1();
        let newW1=this.w1.slice(uv.u.length).concat(uv.v);
        return new DSF(newW0, newW1, arrayPush(this.operatorTrace.slice(), "swap0"));
      }
      this.swap1=function() {
        let newW1=this.w1.slice().reverse();
        let uv=this.getU0V0();
        let newW0=this.w0.slice(uv.u.length).concat(uv.v);
        return new DSF(newW0, newW1, arrayPush(this.operatorTrace.slice(), "swap1"));

        // TODO: use rotation for all duplicate actions?
        // let rotatedResult=new DSF(this.w1, wordRho(1, this.w0)).swap0();
        // return new DSF(rotatedResult.w1, wordRho(1, rotatedResult.w0));// TODO: rotating forwards a second time, should rotate back? DSF(rho(-1, w1), w0) or smth like that
      }
      this.extend0=function() {
        if (this.w1.length==0) {
          console.log("bad input to extend");
          return new DSF([], [], arrayPush(this.operatorTrace.slice(), "extend0"));
        }
        else {
          // let onePeriod=this.w0.slice(0, wordPeriodLen(this.w0));
          // return new DSF(onePeriod.concat(this.w0), this.w1);
          // let u0v0=this.getU0V0();
          // return new DSF(this.w0.concat(u0v0.v).concat(u0v0.u), this.w1);
          // console.log("u0*v0", this.getU0ConcatV0());
          return new DSF(this.getU0ConcatV0().concat(this.w0), this.w1, arrayPush(this.operatorTrace.slice(), "extend0"));
        }
      }
      this.extend1=function() {
        if (this.w0.length==0) {
          console.log("bad input to extend");
          return new DSF([], [], arrayPush(this.operatorTrace.slice(), "extend1"));
        }
        else {
          // let onePeriod=this.w1.slice(0, wordPeriodLen(this.w1));
          // return new DSF(this.w0, onePeriod.concat(this.w1));
          return new DSF(this.w0, this.getU1ConcatV1().concat(this.w1), arrayPush(this.operatorTrace.slice(), "extend1"));
        }
      }
      this.reduceHoweverPossible=function() {// TODO:
        // if (w0) {
        //
        // }
      }
      
      this.updateMirrorM=function() {// TODO: generalize path calculations into a seperate function, they're already used in 3 DSF methods
        // console.log("updateMirrorM");
        let curPos=new Vec2();
        
        let edgeWord=this.w0;
        let runningLen=0;
        let runningAng=0;
        let innerTurnAngBonus=0;
        // for (var j = 0; j < schlafliP; j++) {
        for (var i = 0; i < edgeWord.length; i++) {
          let innerTurnAng=0;
          if (i!=0) {//certain things (like getting the previous segment) will only work if this is not first segment
            innerTurnAng=TAU * (edgeWord[i]-edgeWord[i-1])/schlafliQ;//the angle between the current and previous segments // TODO: i don't fully understand why this works (why eW[i]-eW[i-1] is 1 or -1)
          }
          let innerTurnAngWithBonus=innerTurnAng-innerTurnAngBonus;
          
          // do some trigonometry (using https://en.wikipedia.org/wiki/Hyperbolic_triangle TODO: cite better) to find unknowns in the triangle {old displacement Vector, current path segment, new displacement vector} with angles {new innerTurnAngBonus, runningAngChange, old innerTurnAngWithBonus}
          
          // TODO: make these 3 into one function? (maybe not needed, but there's a lot of copying with slight modifications)
          innerTurnAngBonus=hypSASGetAngleAtFirstSide(this.segmentLength, innerTurnAngWithBonus, runningLen);
          let newRunningLen=hypSASGetThirdEdge(runningLen, innerTurnAngWithBonus, this.segmentLength);
          let runningAngChange=hypSASGetAngleAtFirstSide(runningLen, innerTurnAngWithBonus, this.segmentLength); //how much needs to be added to the running angle. it is equal to the angle between the new and old running-displacement-vectors
          
          runningAng+=runningAngChange;
          runningLen=newRunningLen;
        }
        
        let newMirrorM=Math.tan(hypSASGetAngleAtFirstSide(centerToVertexHyp, PI/schlafliQ+globalEdgeAngleOffset-runningAng, runningLen)/2);
        updateMirrorAngle(newMirrorM);
      }
      this.updateSegmentLength=function() {// TODO: better function (like one that sets a property of this DSF)
        // console.trace("updateSegmentLength");
        let curPos=new Vec2();
        
        // let segLenLowerBound=0.001;     // TODO: arbitrary
        // let segLenUpperBound=3;
        let segLenLowerBound=0;
        let segLenUpperBound=20;
        let segLen;
        
        let edgeWord=this.getEdgeWord();
        const numIterations=70;
        for (var iterations = 0; iterations < numIterations; iterations++) {
          // let differenceWord=[];// TODO: make more efficient with a single difference word
          // for (var i = 1; i < edgeWordLength; i++) {
          //   edgeWord.push(edgeWord[i]-edgeWord[i-1]);
          // }
          // console.log(edgeWord);
          let y2=0;
          let y3=0;
          segLen=(segLenLowerBound+segLenUpperBound)/2;
          
          let runningLen=0;
          let runningAng=0;
          let innerTurnAngBonus=0;
          // for (var j = 0; j < schlafliP; j++) {
          for (var i = 0; i < edgeWord.length; i++) {
            let innerTurnAng=0;
            if (i!=0) {//certain things (like getting the previous segment) will only work if this is not first segment
              innerTurnAng=TAU * (edgeWord[i]-edgeWord[i-1])/schlafliQ;//the angle between the current and previous segments // TODO: i don't fully understand why this works (why eW[i]-eW[i-1] is 1 or -1)
            }
            let innerTurnAngWithBonus=innerTurnAng-innerTurnAngBonus;
            
            // do some trigonometry (using https://en.wikipedia.org/wiki/Hyperbolic_triangle // TODO: cite better) to find unknowns in the triangle {old displacement Vector, current path segment, new displacement vector} with angles {new innerTurnAngBonus, runningAngChange, old innerTurnAngWithBonus}
            
            // TODO: make these 3 into one function? (maybe not needed, but there's a lot of copying with slight modifications)
            innerTurnAngBonus=hypSASGetAngleAtFirstSide(segLen, innerTurnAngWithBonus, runningLen);
            let newRunningLen=hypSASGetThirdEdge(runningLen, innerTurnAngWithBonus, segLen);
            let runningAngChange=hypSASGetAngleAtFirstSide(runningLen, innerTurnAngWithBonus, segLen); //how much needs to be added to the running angle. it is equal to the angle between the new and old running-displacement-vectors
            
            // console.log("Known:", "runningLen", runningLen, "innerTurnAngWithBonus", innerTurnAngWithBonus, "segLen", segLen);
            // console.log("Just calculated:", "innerTurnAngBonus", innerTurnAngBonus, "newRunningLen", newRunningLen, "runningAngChange", runningAngChange);
            
            
            runningAng+=runningAngChange;
            runningLen=newRunningLen;
            // curPos=Vec2FromAngleAndHypLength(runningAng, runningLen);
          }
          if (iterations==numIterations-1) {
            globalEdgeAngleOffset=runningAng;//update globalEdgeAngleOffset // TODO: done here out of convenience, maybe should be made separate
          }
                    
          if (runningLen>edgeLengthHyp) {
            segLenUpperBound=segLen;
          }
          else {
            segLenLowerBound=segLen;
          }
          // console.log(y2, y3);
        }
        this.segmentLength=segLen;
      }
      this.drawWithSettings=function(settings) {
        let ctx=settings.context;
        ctx.lineWidth=1;
        ctx.strokeStyle=settings.strokeStyle;
        ctx.fillStyle=settings.fillStyle;
        
        let edgeVector=this.getEdgeVector();
        let maxDistFromCenter;
        if (settings.useDistFromCenter) {
          maxDistFromCenter=this.getMaxDistFromCenter();
        }
        // console.log(maxDistFromCenter);
        
        // let segLen=1/maxDistFromCenter;
        const segLen=this.segmentLength;
        // const segLen=(-colorChangeSteps/500%1+1)%1 *0.1;
        // const segLen=(-colorChangeSteps/50%1+1)%1 *0.2;
        // const segLen=(-colorChangeSteps/50%1+1)%1 *0.05;
        
        // const startPos=new Vec2(0.5*Math.tan(HPI-PI/schlafliP), 0.5).mult(edgeVector.len());
        // const startPos=new Vec2(-0.5*Math.cot(PI/schlafliP), 0.5).mult(edgeVector.len());// TODO: untested
        // TODO: i don't know why this works
        // set startPos - the point where the path begins drawing - as one of the vertices of the central tile
        // scale the starting point, turning an edge length of 1 (tilingTransforms must create edges of length 1) into an edge length of edgeVector.len())
        
        // const startPos=new Vec2();
        
        // const startingAng=0;
        // let hypTranslationThatTakesTheCenterOfATileToItsVertex=new HypTransform();
        const startingAng=PI-globalEdgeAngleOffset-PI/schlafliQ;
        let hypTranslationThatTakesTheCenterOfATileToItsVertex=new HypTransform(0, centerToVertexHyp);// TODO: rename
        const startingLen=0;// TODO: will 0 cause problems? if not, simplify the rest of the code
        // const startingLen=0.0001;
        // const startingLen=0.3;
        // const startingLen=centerToVertexEuc;
        // console.log(startingLen);
        // const startPos=Vec2FromAngleAndHypLength(startingAng, startingLen);
        // const startPos=Vec2FromAngleAndHypLength(PI-globalEdgeAngleOffset-PI/schlafliQ, startingLen);
        // const startPos=Vec2FromAngleAndHypLength(0, startingLen);
        // const startPos=Vec2FromAngleAndHypLength(0, centerToVertexHyp);
        const startPos=hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(new Vec2());
        
        const tilingTransformNumber=settings.useTilingTransforms ? tilingTransforms.length : 1;//how many of the tiling transforms are going to be used to repeatedly draw the tile
        
        // let edgeWord=this.getBoundaryWord();
        let edgeWord=this.getEdgeWord();
        let edgeWordLength=edgeWord.length;
        for (var j = 1; j < schlafliP; j++) {
          for (var i = 0; i < edgeWordLength; i++) {
            edgeWord.push(edgeWord[i]+j);
          }
        }
        // let differenceWord=[];// TODO: make more efficient with a single difference word
        // for (var i = 1; i < edgeWordLength; i++) {
        //   edgeWord.push(edgeWord[i]-edgeWord[i-1]);
        // }
        // console.log(edgeWord);
        
        for (var ttr = 0; ttr < tilingTransformNumber; ttr++) {// TODO: fewer things can be in this loop (like the edgeWord definition) // TODO: maybe first calculate all the points once and then loop over the transformations {and the points}
            let transf=tilingTransforms[ttr];
            //define the tiles' contact point as the beginning of the boundary
            let curPos=startPos;
          
            ctx.beginPath();
            // let curScreenPos=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(startPos)).add(settings.pos).screen();
            // let curScreenPos=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(curPos)).screen();
            let curScreenPos=transf.applyTo(curPos).mult(globalScaling).screen();// TODO: i think this only helps when pathPoincareEdge fails
            ctx.moveTo(curScreenPos.x, curScreenPos.y);//beginning to draw the path, move to the starting point
            
            // let curPosTransformed=transf.applyTo(curPos);// TODO: would be better than above, but currently it's just the origin (also this isn't tested)
            
            
            // let innerTurnAngBonus=PI+0.00001;
            // let innerTurnAngBonus=0.00001;
            // let innerTurnAngBonus=startingAng;
            let innerTurnAngBonus=0;
            let runningAng=startingAng;
            // let runningLen=startingLen;
            // let runningAng=0;
            let runningLen=0;
            // let lastPosTransformed=transf.applyTo(startPos);
            let lastPosTransformed=transf.applyTo(startPos);
            let curPosTransformed=new Vec2();
        
            // for (var j = 0; j < schlafliP; j++) {
              for (var i = 0; i < edgeWord.length; i++) {
                let innerTurnAng=0;
                if (i!=0) {//certain things (like getting the previous segment) will only work if this is not first segment
                  innerTurnAng=TAU * (edgeWord[i]-edgeWord[i-1])/schlafliQ;//the angle between the current and previous segments // TODO: i don't fully understand why this works
                  // console.log("edgeWord[i]-edgeWord[i-1]", edgeWord[i]-edgeWord[i-1]);
                }
                let innerTurnAngWithBonus=innerTurnAng-innerTurnAngBonus;
                
                // do some trigonometry (using https://en.wikipedia.org/wiki/Hyperbolic_triangle) to find unknowns in the triangle {old displacement Vector, current path segment, new displacement vector} with angles {new innerTurnAngBonus, runningAngChange, old innerTurnAngWithBonus}
                
                // TODO: make these 3 into one function? (maybe not needed, but there's a lot of copying with slight modifications)
                innerTurnAngBonus=hypSASGetAngleAtFirstSide(segLen, innerTurnAngWithBonus, runningLen);
                let newRunningLen=hypSASGetThirdEdge(runningLen, innerTurnAngWithBonus, segLen);
                let runningAngChange=hypSASGetAngleAtFirstSide(runningLen, innerTurnAngWithBonus, segLen); //how much needs to be added to the running angle. it is equal to the angle between the new and old running-displacement-vectors
                
                // console.log("Known:", "runningLen", runningLen, "innerTurnAngWithBonus", innerTurnAngWithBonus, "segLen", segLen);
                // console.log("Just calculated:", "innerTurnAngBonus", innerTurnAngBonus, "newRunningLen", newRunningLen, "runningAngChange", runningAngChange);
                
                runningAng+=runningAngChange;
                runningLen=newRunningLen;
                // console.log("Result:", "runningLen", runningLen, "runningAng", runningAng);
                curPos=Vec2FromAngleAndHypLength(runningAng, runningLen);
                // console.log(curPos);
                
                // let scaledCurPos=curPos.mult(settings.useDistFromCenter ? 1/maxDistFromCenter : 1/edgeVector.len());
                // let curScreenPos=transf.applyTo(scaledCurPos).mult(settings.DSFRelativeRadius).add(settings.pos).screen();//in tessellation // TODO: currently used one is modified from this; do i need the full version for hyperbolic drawing?
                
                // curScreenPos=transf.applyTo(scaledCurPos).add(settings.pos).screen();
                curPosTransformed=transf.applyTo(hypTranslationThatTakesTheCenterOfATileToItsVertex.applyTo(curPos));
                
                // ctx.lineTo(curScreenPos.x, curScreenPos.y);
                
                // console.log(ttr, lastPosTransformed, curPosTransformed);
                // pathPoincareEdge(lastPosTransformed, curPosTransformed);
                pathPoincareEdge(curPosTransformed, lastPosTransformed);// TODO: whyyyyy this order??? should i simultaneously refactor this call, the function, and other calls?
                
                lastPosTransformed=curPosTransformed;
              }
            // }
            
            // console.log(curScreenPos);
            // ctx.fillStyle="#ff09";
            // ctx.fillRect(curScreenPos.x-3, curScreenPos.y-3, 6, 6);
            // ctx.fillStyle="#9999";
            // let endScreenPos=curPos.screen();
            // ctx.fillRect(endScreenPos.x-3, endScreenPos.y-3, 6, 6);
            // ctx.fillStyle="#f119";
            // let edgeEndScreenPos=Vec2FromAngleAndHypLength(globalEdgeAngleOffset, edgeLengthHyp).screen();
            // ctx.fillRect(edgeEndScreenPos.x-3, edgeEndScreenPos.y-3, 6, 6);
            
            // ctx.closePath();
            // ctx.fill("evenodd");
            ctx.stroke();
          }
      }
      this.drawToWholeScreen=function() {
        let settings=new DSFDrawingSettings();
        settings.DSFRelativeRadius=globalScaling;
        settings.useTilingTransforms=true;
        // settings.context=changingContext;
        // settings.pos=new Vec2(1, 0).mult(globalScaling);
        // settings.fillStyle="#048c";
        this.drawWithSettings(settings);
      }
      this.isEqualTo=function(d) {// TODO: this should check if they're eqivalent after rotation or mirroring (i.e. w0*w1==w1*wordRho(1, w0))
        if (this.w0.length==d.w0.length && this.w1.length==d.w1.length) {
          for (var i = 0; i < this.w0.length; i++) {
            if (this.w0[i]!=d.w0[i]) return false;
          }
          for (var i = 0; i < this.w1.length; i++) {
            if (this.w1[i]!=d.w1[i]) return false;
          }
          return true;
        }
        else {
          return false;
        }
      }
      this.turningNumber=function() {
        if (this.len()==0) {
          return 0;
        }
        let T=0;
        let word=this.getBoundaryWord();
        for (var i = 0; i < word.length; i++) {
          let prevLetter= i==0 ? word[word.length-1] : word[i-1];
          let curTurn=mod(word[i]-prevLetter, schlafliP);// (w[i]-w[i-1]) % schlafliP
          if (curTurn!=schlafliP/2) {
            if (curTurn>schlafliP/2) curTurn-=schlafliP;
            T+=curTurn;
          }
        }
        return T/schlafliP;
      }
      this.isValidInSomeNotYetClearWay=function() {// TODO:
        let edge0=this.w0.slice().concat(this.w1);
        let edge1=this.w1.slice().concat(wordRho(1, this.w0));
        // console.log("first test", arraysShallowEqual(edge0, edge0.slice().reverse()), "second", arraysShallowEqual(edge1, edge1.slice().reverse()));
        // console.log(edge1, edge1.slice().reverse());
        // TODO: is turning number needed?
        // console.log(Math.abs(this.turningNumber()));
        // if (arraysShallowEqual(edge0, edge0.slice().reverse()) && arraysShallowEqual(edge1, edge1.slice().reverse()) && Math.abs(this.turningNumber())==1) {
        if (arraysShallowEqual(edge0, edge0.slice().reverse()) && arraysShallowEqual(edge1, edge1.slice().reverse())) {
          return true;
        }
        return false;
      }
      this.isValidPolyform=function() {// TODO: would likely be useful

      }
    }
    function DSFDrawingSettings() {
      this.context=context;
      this.pos=new Vec2();
      this.DSFRelativeRadius=DSFGridScaling;// TODO: rename // TODO: different default?
      this.strokeStyle="#fff";
      this.fillStyle="#0000";
      this.useTilingTransforms=false;
      this.useDistFromCenter=false;
    }

    // var curDSF=new DSF([0,1,0,1], [2,1,2,1,0,1,0]);
    // var curDSF=new DSF([0], [1,0,1,0]);
    // var curDSF=new DSF([1,0,1,0], [1]);
    // var curDSF=new DSF([1,0,1,0,5,0,5,4,5,4], [5,0,5,0,1,0,1,2,1,2,1,0,1,0,5,0,5,4,5,4,5,0,5,0,1,0,1]);
    // var curDSF=new DSF([5,0,5,0,1,0,1,2,1,2,1,0,1,0,5,0,5,4,5,4,5,0,5,0,1,0,1], [2,1,2,1,0,1,0,5,0,5]);
    // var curDSF=new DSF([0], []);
    
    // var curDSF=new DSF([0,0,2,3], []);
    // var curDSF=new DSF([0,0,2], []);// TODO: this is still broken (and i don't expect that i'll fix it)
    // var curDSF=new DSF([0,1,0,1,2,1], []);

    function logCurDSFInfo() {
      console.log("%c"+curDSF.w0+" and "+curDSF.w1, "font-size: 180%; color: #9f6; padding-top:2%; padding-bottom: 2%");
      console.log(wordRho(-1, curDSF.w0), wordRho(-1, curDSF.w1), curDSF.w0, curDSF.w1, wordRho(1, curDSF.w0), wordRho(1, curDSF.w1));
      console.log("%c                                                   ", "display: inline-block; border: 2px solid lightgray; font-size:1px");
      // console.log("%cha", "border-radius:10px");
      let uv0=curDSF.getU0V0();
      console.log("u0", uv0.u, "v0", uv0.v);
      let uv1=curDSF.getU1V1();
      console.log("u1", uv1.u, "v1", uv1.v);
      console.log("%c                                                   ", "display: inline-block; border: 2px solid lightgray; font-size:1px");
    }

    // var curDSF=new DSF([], [0]);
    // curDSF=curDSF.extend0();
    var curDSF=new DSF([0], []);// TODO: DSF([0], []) doesn't draw correctly in {5, 4}
    curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.swap1();// TODO: generation seems broken // TODO: why did i write that???
    // curDSF=curDSF.swap0();
    // curDSF=curDSF.swap1();
    // curDSF=curDSF.swap1();
    // curDSF=curDSF.extend0();
    // curDSF=curDSF.extend1();
    // curDSF=curDSF.extend0();
    // curDSF=curDSF.swap0();
    // curDSF=curDSF.swap1();
    // curDSF=curDSF.trimIfPossible();
    // logCurDSFInfo();
    // console.log("%cresult", "font-size:200%; padding:1%");
    // console.log(curDSF.w0, curDSF.w1);
    console.log("Result: |w0|="+curDSF.w0.length+", |w1|="+curDSF.w1.length);

    var resultingDSFArray=[];
    function generateDSFGrid() {// TODO: hyperbolic tile support
      const gridHeight=4;
      const gridWidth=Math.floor(gridHeight*canvas.width/canvas.height);
      const numToGenerate=gridHeight*gridWidth;
      // const UOperatorNames=["extend0", "extend1", "swap0", "swap1"];
      let T=[];
      resultingDSFArray=[];
      let Q=[curDSF];//words on which no operations have been done
      while (resultingDSFArray.length<numToGenerate) {//generate into T until its length reaches numToGenerate
        if (Q.length==0) {
          console.warn("Q ran out of elements (should be impossible in standard conditions)!");
          break;
        }
        // let S=Q.pop();
        let S=Q.shift();

        let SIsNotYetInT=true;
        for (var ti = 0; ti < T.length; ti++) {//check if S is in T
          if (S.isEqualTo(T[ti])) SIsNotYetInT=false;
        }
        if (SIsNotYetInT) {
          T.push(S);
          // console.log(S.isValidInSomeNotYetClearWay());// TODO: always true, even when self-crossing
          if (S.isValidInSomeNotYetClearWay()) resultingDSFArray.push(S);
        }

        let U=[S.extend0(), S.extend1(), S.swap0(), S.swap1()];
        // console.log(U);
        // console.log(S.extend1());
        for (var ui = 0; ui < U.length; ui++) {
          let alreadyGenerated=false;

          for (var qi = 0; qi < Q.length; qi++) {//check if U[ui] is in Q
            if (Q[qi].isEqualTo(U[ui])) alreadyGenerated=true;
          }
          for (var ti = 0; ti < T.length; ti++) {//check if U[ui] is in T
            if (T[ti].isEqualTo(U[ui])) alreadyGenerated=true;
          }
          // console.log("!alreadyGenerated", !alreadyGenerated);
          if (!alreadyGenerated) {
            // console.log("U[ui].length>S.length", U[ui].length>S.length);
            // console.log(U[ui], S);
            if (U[ui].len()>S.len()) {
              Q.push(U[ui]);
            }
          }
        }
      }
      console.log("resultingDSFArray", resultingDSFArray);
      let settings=new DSFDrawingSettings();
      settings.fillStyle="#8a1";
      settings.DSFRelativeRadius=DSFGridScaling/gridHeight;
      settings.useDistFromCenter=true;

      for (var i = 0; i < gridHeight; i++) {
        for (var j = 0; j < gridWidth; j++) {
          let wordIndex=i*gridWidth+j;
          // if (wordIndex>=1) {
          if (wordIndex>=resultingDSFArray.length) {//ran out of tiles! (normally shouldn't be possible)
            return undefined;
          }
          // settings.pos=new Vec2((j*2-gridWidth+1)/gridHeight, (i*2-gridHeight+1)/gridHeight);// TODO: why was this mirrored vertically? something might be messed up elsewhere... (or maybe i want positive y to be downwards?)
          settings.pos=new Vec2((j*2-gridWidth+1)/gridHeight, -(i*2-gridHeight+1)/gridHeight);
          // console.log(settings.pos);
          resultingDSFArray[wordIndex].drawWithSettings(settings);

          ////debug points (centers of tiles)
          // context.fillStyle="#f00";
          // let curPos=new Vec2((j*2-gridWidth+1)/gridHeight, (i*2-gridHeight+1)/gridHeight).screen();
          // context.fillRect(curPos.x-1, curPos.y-1, 2, 2);
        }
      }
      // context.fillRect(canvas.width/2-1.5, canvas.height/2-1.5, 3, 3);
    }
    
    
    ;//COLORS
      function Color(r=255, g=0, b=255, a=1) {
        this.r=r;
        this.g=g;
        this.b=b;
        this.a=a;
        this.copy=function() {
          return new Color(this.r, this.g, this.b, this.a);
        }
        this.each=function(f) {
          return new Color(f(this.r), f(this.g), f(this.b));
        }
        this.modify=function(amp) {
          return this.each(function(n) {
            var x=n+rand0(amp);
            if (x>255) {
              return 255;
            }
            else if (x<0) {
              return 0;
            }
            else {
              return x;
            }
          });
        }
        this.add=function(v) {
          return new Color(this.r+v.r, this.g+v.g, this.b+v.b);
        }
        this.lighten=function(v) {
          return new Color(v*(256-this.r)+this.r, v*(256-this.g)+this.g, v*(256-this.b)+this.b);
        }
        this.sub=function(v) {
          return new Color(this.r-v.r, this.g-v.g, this.b-v.b);
        }
        this.mult=function(v) {
          return new Color(this.r*v, this.g*v, this.b*v);
        }
        this.multColor=function(c) {
          return new Color(this.r*c.r/256, this.g*c.g/256, this.b*c.b/256);
        }
        this.rgb=function() {
          return "rgb("+this.r+","+this.g+","+this.b+")";
        }
        this.square=function() {
          return new Color(this.r**2, this.g**2, this.b**2, this.a);
        }
        this.sqrt=function() {
          return new Color(Math.sqrt(this.r), Math.sqrt(this.g), Math.sqrt(this.b), this.a);
        }
        this.grayen=function(amp) {
          return this.each(function(n){
            return n*(1-amp)+128*amp;
          });
        }
      }
      function ColorFromHSL(h=5/6, s=1, l=0.5, a=1) {
        // TODO: this is dumb (alsoneed a reference)
        h=(h%1+1)%1;
        let c = (1 - Math.abs(2 * l - 1)) * s,
            x = c * (1 - Math.abs((h*6) % 2 - 1)),
            m = l - c/2,
            r = 0,
            g = 0,
            b = 0;

        if (0 <= h && h < 1/6) {
          r = c; g = x; b = 0;
        }
        else if (1/6 <= h && h < 1/3) {
          r = x; g = c; b = 0;
        } else if (1/3 <= h && h < 1/2) {
          r = 0; g = c; b = x;
        } else if (1/2 <= h && h < 2/3) {
          r = 0; g = x; b = c;
        } else if (2/3 <= h && h < 5/6) {
          r = x; g = 0; b = c;
        } else if (5/6 <= h && h < 1) {
          r = c; g = 0; b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);

        return new Color(r, g, b, a);
      }
      function Gradient(v) {
        this.colors=[];
        this.values=[];
        for (var i = 0; i < v.length; i+=2) {
          this.colors[i/2]=v[i];
          this.values[i/2]=v[i+1];
        }
        this.get=function(x) {
          for (var i = 0; i < this.values.length; i++) {
            if (this.values[i]>x) {
              if (i==0) {
                return this.colors[0].copy();
              }
              else {
                // return this.colors[i].sub(this.colors[i-1]).mult((x-this.values[i-1])/(this.values[i]-this.values[i-1])).add(this.colors[i-1]); // simple, ugly mixing
                return this.colors[i].square().sub(this.colors[i-1].square()).mult((x-this.values[i-1])/(this.values[i]-this.values[i-1])).add(this.colors[i-1].square()).sqrt(); // complicated, expesive, prettier mixing
              }
            }
          }
          return this.colors[this.colors.length-1].copy();
        }
      }
      var colors={//list of all predefined colors
        // mist: new Color(110, 130, 210),
        // sky: new Color(50, 150, 210),
        // darkBrown: new Color(40, 17, 2),
        // lightBrown: new Color(200, 160, 60),
        // sand: new Color(200, 170, 120),

        white: new Color(255, 255, 255),
        black: new Color(0, 0, 0),
        red: new Color(255, 0, 0),
        green: new Color(0, 255, 0),
        blue: new Color(0, 0, 255),
        yellow: new Color(255, 255, 0),
        magenta: new Color(255, 0, 255),
        cyan: new Color(0, 255, 255),

        darkRed: new Color(127, 0, 0),
        darkGreen: new Color(0, 127, 0),
        darkBlue: new Color(0, 0, 127),
        darkYellow: new Color(127, 127, 0),
        darkMagenta: new Color(127, 0, 127),
        darkCyan: new Color(0, 127, 127),
        // veryDarkRed: new Color(63, 0, 0),
        // veryDarkGreen: new Color(0, 63, 0),
        // veryDarkBlue: new Color(0, 0, 63),
        // veryDarkYellow: new Color(63, 63, 0),
        // veryDarkMagenta: new Color(63, 0, 63),
        // veryDarkCyan: new Color(0, 63, 63),

        orange: new Color(255, 127, 0),
        gray: new Color(127, 127, 127),
        darkGray: new Color(63, 63, 63),
        darkGray: new Color(63, 63, 63),
        slate: new Color(50, 67, 127)
        // brown: new Color(64, 32, 0)
      }
      var gradients={// TODO: not really used much
        leafy: new Gradient([colors.veryDarkGreen, 0, colors.green, 0.5, colors.yellow, 1]),
        rainbow: new Gradient([colors.black, 0, colors.red, 0.1, colors.yellow, 0.26, colors.green, 0.42, colors.cyan, 0.58, colors.blue, 0.74, colors.magenta, 0.9, colors.white, 1]),
        natural: new Gradient([colors.black, 0, colors.green, 0.6, colors.yellow, 0.8, colors.white, 0.9, colors.red, 1]),
        tech: new Gradient([colors.black, 0, colors.darkBlue, 0.3, colors.cyan, 0.6, colors.white, 1]),
        flame: new Gradient([colors.black, 0, colors.darkBlue, 0.1, colors.white, 0.24, colors.yellow, 0.38, colors.red, 0.7, colors.black, 1]),
        middleBand: new Gradient([colors.black, 0.4, colors.white, 0.401, colors.white, 0.599, colors.black, 0.6]),
        middleNarrowBand: new Gradient([colors.white, 0.47, colors.black, 0.472, colors.black, 0.528, colors.white, 0.53]),
        blendingTest: new Gradient([colors.green, 0, colors.red, 1])
      }
      var useGradient=gradients.tech;

      // var takeColors=[[255,255,0],
      //   [213, 94, 0],
      //   [0, 114, 178],
      //   [230, 220, 60],
      //   [204, 121, 167],
      //   [0, 158, 115],
      //   [86, 180, 233],
      //   [230, 159, 0]
      // ]
      // for (var i = 0; i < takeColors.length; i++) {
      //   var curColor=new Color(takeColors[i][0], takeColors[i][1], takeColors[i][2]);
      //   var curFaceColor=curColor.rgb();
      //   curFaceColor=curFaceColor.substring(0, curFaceColor.length-1)+",30%)";
      //   takeColors[i]={
      //     vertex: curColor.rgb(),
      //     edge: curColor.rgb(),
      //     face: curFaceColor
      //   }
      // }

      var drawColors=[];
      for (const col in colors) {//initialize drawColors with all predefined colors
        drawColors.push(colors[col]);
      }
      for (var i = 0; i < drawColors.length; i++) {//add color select elements
        document.getElementById("color-select-dropdown").innerHTML+="<div class='color-select-option' style='background-color: "+drawColors[i].rgb()+"' onclick='selectFillColor(drawColors["+i+"])'> </div>";
      }
      
      var boundaryCircleColor="hsla(0, 0%, 100%, 0.7)";
      var hypPolyEdgeColor="rgb(110, 110, 110)";
      var hypPolyVertDefaultColor="rgb(220, 220, 220)";
    
      var BGColor=new Color(0, 0, 0);
      var fillColor=new Color(255, 255, 255);
      var fillColorWithErase=fillColor;//temporary color (same as fillColor except when erasing, then it's the background color)
    
    function Vec2(x=0, y=0) {
      this.x=x;
      this.y=y;
      this.copy=function() {
        return new Vec2(this.x, this.y);
      }
      this.add=function(v1, v2) {// FIXME: doesn't always work with both values
        if (v2!=undefined) {
          return new Vec2(this.x+v1, this.y+v2);
        }
        return new Vec2(this.x+v1.x, this.y+v1.y);
      }
      this.sub=function(v) {
        return new Vec2(this.x-v.x, this.y-v.y);
      }
      this.mult=function(n) {
        return new Vec2(this.x*n, this.y*n);
      }
      this.div=function(n) {
        return new Vec2(this.x/n, this.y/n);
      }
      this.dot=function(v) {
        return v.x*this.x + v.y*this.y;
      }
      this.iHatLanding=function(v) {
        return new Vec2(v.x*this.x-v.y*this.y, v.x*this.y+v.y*this.x);
      }
      this.len=function() {
        return Math.sqrt(this.x**2+this.y**2);
      }
      this.sqLen=function() {
        return this.x**2+this.y**2;
      }
      this.dist=function(v) {
        return Math.sqrt((this.x-v.x)**2+(this.y-v.y)**2);
      }
      this.sqDist=function(v) {
        return (this.x-v.x)**2+(this.y-v.y)**2;
      }
      this.unit=function() {
        var len=Math.sqrt(this.x**2+this.y**2);
        return new Vec2(this.x/len, this.y/len);
      }
      this.ang=function() {//angle to x axis in radians
        return Math.atan2(this.y, this.x);
      }
      this.taxi=function() {//taxicab distance
        return this.x+this.y;
      }
      this.screen=function() {//coordinates for drawing
        // return new Vec2(this.x-0.5*this.y, this.y*HALFROOT3);
        return new Vec2(this.x*height/2+canvas.width/2, height/2-this.y*height/2);// TODO: not quite to screen height, also optimize?
        // return new Vec2(0.5*(this.x*canvas.height+canvas.width), ((this.y+1)*0.5)*canvas.height);// TODO: is this one better?
      }
      this.unscreen=function() {//coordinates for mouse interaction
        return new Vec2((this.x-canvas.width/2)*2/height, (height/2-this.y)*2/height);// TODO:
      }
      this.rotate=function(a) {
        return new Vec2(this.x*Math.cos(a)-this.y*Math.sin(a), this.x*Math.sin(a)+this.y*Math.cos(a));
      }
    }
    function Vec2FromAngleAndLength(ang, len=1) {
      return new Vec2(len*Math.cos(ang), len*Math.sin(ang));
    }
    function Vec2FromAngleAndHypLength(ang, len=1) {
      len=hypToEucDist(len);
      return new Vec2(len*Math.cos(ang), len*Math.sin(ang));
    }
    
    // //Affine2 definition, not used anymore
    // function Affine2(iHatX=1, iHatY=0, jHatX=0, jHatY=1, shiftX=0, shiftY=0) {//class for a 2D affine transformation
    //   this.iHatX=iHatX;
    //   this.iHatY=iHatY;
    //   this.jHatX=jHatX;
    //   this.jHatY=jHatY;
    //   this.shiftX=shiftX;
    //   this.shiftY=shiftY;
    //   this.getCopy=function() {// TODO: untested (unnecessary?)
    //     return new Affine2(this.iHatX, this.iHatY, this.jHatX, this.jHatY, this.shiftX, this.shiftY);
    //   }
    //   this.getIHat=function(){return new Vec2(this.iHatX, this.iHatY);};
    //   this.getJHat=function(){return new Vec2(this.jHatX, this.jHatY);};
    //   this.getShift=function(){return new Vec2(this.shiftX, this.shiftY);};
    //   this.applyTo=function(v) {
    //     return new Vec2(v.x*this.iHatX+v.y*this.jHatX+this.shiftX, v.x*this.iHatY+v.y*this.jHatY+this.shiftY);
    //   }
    //   this.scaleShiftBy=function(s) {//multiply the shifting vector by s
    //     let copy=this.getCopy();
    //     copy.shiftX*=s;
    //     copy.shiftY*=s;
    //     return copy;
    //   }
    //   this.scaleTransformBy=function(s) {//multiply the linear transformation matrix by s
    //     let copy=this.getCopy();
    //     copy.iHatX*=s;
    //     copy.iHatY*=s;
    //     copy.jHatX*=s;
    //     copy.jHatY*=s;
    //     return copy;
    //   }
    // }
    // function Affine2FromShift(v) {
    //   return new Affine2(1, 0, 0, 1, v.x, v.y);
    // }
    // function Affine2FromAngle(a) {
    //   return new Affine2(Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a), 0, 0);
    // }
    // function Affine2FromAngleAndShift(a, v) {
    //   return new Affine2(Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a), v.x, v.y);
    // }
    
    function HypTransform(shiftAng=0, shiftDist=0, rotateAng=0) {//hyperbolic isometry, with rotation by rotateAng and then a translation that moves the origin to the polar coordinates {shiftAng, shiftDist}
      this.shiftDist=shiftDist;
      this.shiftAng=shiftAng;
      this.rotateAng=rotateAng;
      this.getCopy=function() {
        return new HypTransform(this.shiftAng, this.shiftDist, this.rotateAng);
      }
      this.applyTo=function(v) {
        let res=v.rotate(this.rotateAng-this.shiftAng);
        res=this.applyTranslationTo(res);
        res=res.rotate(this.shiftAng);
        return res;
      }
      this.applyTranslationTo=function(v) {
        if (isEuclidean) {
          return new Vec2(v.x+this.shiftDist, v.y);
        }
        else {
          let ex=Math.exp(this.shiftDist)
          //formula adapted from the final equation in the answer by MvG (https://math.stackexchange.com/users/35416/mvg), Rigid body motion on the Poincare disc model of the hyperbolic plane, URL (version: 2013-02-19): https://math.stackexchange.com/q/308492
          return new Vec2(
            (ex*v.x+v.x+ex-1) * (ex*v.x-v.x+ex+1) - (ex*v.y+v.y) * (v.y-ex*v.y),
            4*ex*v.y
          ).div((ex*v.x-v.x+ex+1)**2 + (ex*v.y-v.y)**2);
          // return new Vec2(// TODO: optimize? (same as in applyTo)
        //   (ex*v.x+v.x+ex-1) * (ex*v.x-v.x+ex+1) - (ex*v.y+v.y) * (v.y-ex*v.y),
        //   4*ex*v.y
        // ).div((ex*v.x-v.x+ex+1)**2 + (ex*v.y-v.y)**2);
        }
      }
      
      // TODO: unimplemented. are these two functions needed?
      this.scaleShiftBy=function(s) {//multiply the shifting vector by s
        let copy=this.getCopy();
        copy.shiftDist*=s;
        return copy;
      }
      this.scaleTransformBy=function(s) {//multiply the linear transformation matrix by s
        let copy=this.getCopy();
        // copy.iHatX*=s;
        // copy.iHatY*=s;
        // copy.jHatX*=s;
        // copy.jHatY*=s;
        return copy;
      }
    }
    function hypSASGetAngleAtFirstSide(a, C, b) {// In a hyperbolic triangle, given two edges a, b and the angle between them, calculate the angle opposite b // TODO: rename?
      // if (mod(C, TAU)==0) {
      if (Math.abs(mod(C, TAU))<=0.0000001) {// TODO: use an epsilon (?)
        if (a<b) {
          return PI;
        }
        else if (b<a) {
          return 0;
        }
        else {
          return HPI;
        }
      }
      if (isEuclidean) {
        let c=hypSASGetThirdEdge(a, C, b);
        if (a<b) {
          let A=Math.asin(a*Math.sin(C)/c);
          return PI-C-A;
        }
        else {
          let B=Math.asin(b*Math.sin(C)/c);
          return B;
        }
      }
      else {
        //formula adapted from https://en.wikipedia.org/wiki/Hyperbolic_triangle on 16.07.2021
        // return Math.acot((Math.sinh(a)*Math.coth(b)-Math.cos(C)*Math.cosh(a))/Math.sin(C));//direct copy, but these functions are not defined
        // return Math.atan(Math.sin(C)/(Math.sinh(a)/Math.tanh(b)-Math.cos(C)*Math.cosh(a)));//modified to work, but this still breaks in some edge cases
        let res=Math.atan(Math.sin(C)/(Math.sinh(a)/Math.tanh(b)-Math.cos(C)*Math.cosh(a)));
        if (res<0 ^ mod(C, TAU)>PI) {// TODO: i got to this solution while messing around on desmos, some kind of proof/explanation would be fitting
          res+=PI;
        }
        return res;
      }
    }
    function hypSASGetThirdEdge(a, C, b) {// In a hyperbolic triangle, given two edges and the angle between them, calculate the third edge // TODO: rename?
      if (isEuclidean) {
        let res=a*a+b*b-2*a*b*Math.cos(C);//law of cosines
        return Math.sqrt(res);
        // return res>=0 ? Math.sqrt(res) : 0;// TODO: will i need this?
      }
      else {
        //formula taken from https://en.wikipedia.org/wiki/Hyperbolic_triangle on 16.07.2021
        let res=Math.cosh(a)*Math.cosh(b)-Math.sinh(a)*Math.sinh(b)*Math.cos(C);
        return res>=1 ? Math.acosh(res) : 0;// TODO: kinda janky but i probably can't avoid it
      }
    }
    function hypToEucDist(rho) {
      if (isEuclidean) {
        return rho;
      }
      else {
        //formula from "Poincare’s Disk Model for Hyperbolic Geometry" section 9.2.2 retrieved from https://www.ms.uky.edu/~droyster/courses/spring08/math6118/Classnotes/Chapter09.pdf on 16.07.2021
        return Math.tanh(rho/2);
      }
    }
    function eucToHypDist(r) {
      if (isEuclidean) {
        return r;
      }
      else {
        //formula from "Poincare’s Disk Model for Hyperbolic Geometry" section 9.2.2 retrieved from https://www.ms.uky.edu/~droyster/courses/spring08/math6118/Classnotes/Chapter09.pdf on 16.07.2021
        return 2*Math.atanh(r);
      }
    }

    function Polygon() {// TODO: classes with push, not weird index saving
      this.numNext=0;
      this.next=[];
      this.numVerts=0;
      this.verts=[];
      this.layer=0;
      // this.centerPos=new Vec2();
      this.centerAngFromXAxis=0;
      this.centerToOriginHyp=0;
      this.vertexOffsetAngle=0;//angle by which to rotate the polygon so that one of its vertices would be horizontal relative to its center // TODO: i don't know what that means in the hyperbolic plane
      this.addNext=function (n) {
        this.next[this.numNext]=n;
        this.numNext++;
      }
      this.addVert=function (v) {
        this.verts[this.numVerts]=v;
        this.numVerts++;
      }
    };
    function Vert() {
      this.numNext=0;
      this.next=[];
      this.numPolys=0;
      this.polys=[];
      this.pos=new Vec2();
      this.drawPos=new Vec2();
      this.takenByNumber=0;
      this.radius=0;
      this.addNext=function(n) {
        this.next[this.numNext]=n;
        this.numNext++;
      }
      this.addPoly=function(p) {
        this.polys[this.numPolys]=p;
        this.numPolys++;
      }
      this.setPos=function(v) {
        this.pos=v.copy();
        this.magnit=this.pos.len();

        // this.drawPos=v.copy();
        // this.drawPos=v.mult(v.len());
        // this.radius=0.13*(1-v.sqLen());
        // this.radius=0.08*(1-this.drawPos.sqLen());
        // this.drawPos=v.square();
        // this.drawPos=new Vec2(v.x, v.y);

        // let y=(Math.cosh(edgeLengthHyp*hypPolyVertRadius)-1)/2;
        // // isEuclidean ? 10 :
        // let fracBottom=1-y*this.magnit**2+y;
        // this.radius=isEuclidean ? edgeLengthHyp*hypPolyVertRadius : (1-this.magnit*this.magnit)*Math.sqrt(y*(y+1))/fracBottom;
        // // let drawCenterDist=this.magnit/fracBottom;
        // this.drawPos=this.pos.mult(1/fracBottom);

        let distortPos=distortion(this.pos);
        // TODO: where does this come from? what does this do? (i think it' s something from my notes)
        let y=(Math.cosh(edgeLengthHyp*hypPolyVertRadius)-1)/2;
        let fracBottom=1-y*this.magnit**2+y;
        this.radius=isEuclidean ? edgeLengthHyp*hypPolyVertRadius : (1-this.magnit*this.magnit)*Math.sqrt(y*(y+1))/fracBottom;
        // this.radius=0.01;
        // let drawCenterDist=this.magnit/fracBottom;
        this.drawPos=distortPos.mult(1/fracBottom);
      }
      this.draw=function() {
        let screenPos=this.drawPos.screen();

        // context.beginPath();//clear circle (may cause pixel-wide dark areas around circles)
        //   context.arc(screenPos.x, screenPos.y, this.radius*height/2, 0, TAU);
        //   context.fillStyle=BGColor.rgb();
        //   context.fill();

        context.beginPath();
        context.arc(screenPos.x, screenPos.y, this.radius*height/2, 0, TAU);
        context.fillStyle=hypPolyVertDefaultColor;
        context.fill();
      }
    };

    function smootherStep(x) {
      return x * x * x * (x * (x * 6 - 15) + 10);
    }
    function getSmoothWeightedAverage(x, v1=0, v2=1) {//lerp, but with smootherstep
      return x * x * x * (x * (x * 6 - 15) + 10)*(v2-v1)+v1;
    }
    function getWeightedSquareAverage(x, y, v1, v2, v3, v4) {//smooth interpolation
      return getSmoothWeightedAverage(y, getSmoothWeightedAverage(x, v1, v2), getSmoothWeightedAverage(x, v3, v4));
    }
    function getNoise(i, j, seed=0) {//get perlin noise at (i, j)
      var fi=Math.floor(i);
      var fj=Math.floor(j);
      var reli=i-fi;
      var relj=j-fj;
      function getCurrentDot(iOff, jOff) {
        var ang=((fi+iOff)*2+((fj+jOff+seed)*(seed+1))**2)**2;
        // var ang=((fi+iOff)+(fj+jOff)*2)**2;
        return Math.cos(ang)*(reli-iOff)+Math.sin(ang)*(relj-jOff);
      }
      return getWeightedSquareAverage(reli, relj, getCurrentDot(0, 0), getCurrentDot(1, 0), getCurrentDot(0, 1), getCurrentDot(1, 1))*0.8591+0.5;
    }

    function drawSquare(pos, w=4) {
      pos=pos.screen();
      // context.fillRect(0.08*pos.x*canvas.height+0.34*canvas.width, (pos.y*0.08+0.1)*canvas.height, w, w);
      context.fillRect(pos.x-w/2, pos.y-w/2, w, w);
    }
    function drawLine(p1, p2) {
      p1=p1.screen();
      p2=p2.screen();
      context.beginPath();
      context.moveTo(p1.x, p1.y);
      context.lineTo(p2.x, p2.y);
      context.stroke();
    }
    function drawDisk(x, y, r=4, ctx=context) {
      ctx.beginPath();
      // ctx.moveTo(0.5*(x*canvas.height+canvas.width), ((y+1)*0.5)*canvas.height);
      // ctx.arc(0.5*(x*canvas.height+canvas.width), ((y+1)*0.5)*canvas.height, r/2+0.5, 0, TAU);
      ctx.moveTo(0.5*(x*canvas.height+canvas.width), ((1-y)*0.5)*canvas.height);
      ctx.arc(0.5*(x*canvas.height+canvas.width), ((1-y)*0.5)*canvas.height, r/2+0.5, 0, TAU);
      ctx.fill();
    }

    function pathPoincareEdge(v1, v2, ctx=context) {//add one edge's (from v1 to v2) arc-shaped path to context
      // if (true) {//arc edges
        // console.log(v1, v2);
        // if (!isEuclidean) {
          var scaleM=((radius/v1.len())**2 + 1)/2;
          var scaleN=((radius/v2.len())**2 + 1)/2;
          var M=v1.mult(scaleM);
          var N=v2.mult(scaleN);
          // var centerY=(M.x*(M.x-N.x-N.y*N.y/N.x)+M.y*M.y)/(M.y-N.y*M.x/N.x);
          let centerY=(M.x*(M.x*N.x-N.x*N.x-N.y*N.y)+M.y*M.y*N.x)/(M.y*N.x-N.y*M.x);// TODO: is this safer???
          var prevC=new Vec2(M.x+M.y*(M.y-centerY)/M.x, centerY);
          var newR=(prevC.sub(v1)).len();
          // console.log(newR);
        // }
        if (isEuclidean || newR>=10000 || Number.isNaN(newR)) {// TODO: there has to be a better way to avoid huge radiuses (like homogenous coordinates)
        // if (newR>=10000 || Number.isNaN(newR)) {// TODO: removing isEuclidean conditions seems to successfully draw euclidean shapes in the poincare disk, if that makes sense. maybe it'll cause problems down the line!
          // var v1Screen=v1.screen();
          var v1Screen=v1.mult(globalScaling).screen();
          // var v2Screen=v2.screen();
          // ctx.moveTo(v1Screen.x, v1Screen.y);
          // ctx.lineTo(v2Screen.x, v2Screen.y);
          // ctx.moveTo(v2Screen.x, v2Screen.y);
          ctx.lineTo(v1Screen.x, v1Screen.y);
        }
        else {
          // console.log(newR);
          var prevCScreen=prevC.mult(globalScaling).screen();
          var ang1=-v1.sub(prevC).ang();
          var ang2=-v2.sub(prevC).ang();
          var widd=(ang1-ang2+TAU)%TAU>PI;
          ctx.arc(prevCScreen.x, prevCScreen.y, newR*globalScaling*height/2, ang2, ang1, widd);
        }
      // }
      // else {//straight edges
      //   drawLine(v1, v2);//straight lines, alternative to arcs
      // }
    }
    function pathPoincarePoly(vertArr) {//add one polygon's (as an array of indexes in V[]) path to context
      var avgVertPos=new Vec2();
      context.beginPath();
      let firstVertScreen=V[vertArr[0]].pos.screen();
      context.moveTo(firstVertScreen.x, firstVertScreen.y);
      for (var j=0; j<vertArr.length; j++) {//all edges
        var v1=V[vertArr[(j+1)%vertArr.length]].pos;
        var v2=V[vertArr[j]].pos;
        // console.log(j, v1, v2);
        pathPoincareEdge(v1, v2);
        avgVertPos=avgVertPos.add(v1);
      }
      // context.closePath();
      avgVertPos=avgVertPos.div(schlafliP);
      return {
        "avgVertPos": avgVertPos
      }
    }
    function drawGridPoly(vertArr) {//draw a polygon which is part of the hyperbolic grid
      var pathData=pathPoincarePoly(vertArr);
      // var avgVertPos=pathData;
      // var color=new Color(randRange(30, 256), randRange(30, 256), randRange(30, 256));
      // var color=useGradient.get(rand());
      var color=useGradient.get(rand()).grayen(0.2).modify(50);
      context.lineWidth=isEuclidean
        ? 0.025*height/2
        : hypPolyEdgeWidth*(1-pathData.avgVertPos.sqLen())*height/2;
      // context.strokeStyle="rgb(0, 0, 0)";
      // context.strokeStyle="rgb(220, 220, 220)";
      context.strokeStyle=hypPolyEdgeColor;
      // context.lineWidth=1;
      // context.strokeStyle=color.rgb();
      context.fillStyle=color.rgb();
      // context.fill();
      context.stroke();
    }
    function drawAllVerts() {//draw circles on vertices of the hyperbolic grid
      for (var i=0; i<numVerts; i++) {//all polygons
        V[i].draw();
      }
    }




    var tilingTransforms=[];
    var inTileTransforms=[];// TODO: full affine transformation array instead?
    var mirrorM; // m of the mirror line y=mx

    function setInTileTransforms() {//define the linear transformations used to make the central tile (like order 6 rotational and mirror symmetries (AKA D6) to make a snowflake)
      inTileTransforms=[];
      let s=schlafliP;
      for (var i = 0; i < s; i++) {
        var ang=i*TAU/s;
        inTileTransforms.push([Math.cos(ang), Math.sin(ang), -Math.sin(ang), Math.cos(ang)]);
      }
      if (useMirrors) {
        let mirrorMult=1/(1+mirrorM**2);
        let mirrorMatrix=[
          mirrorMult*(1-mirrorM**2),
          mirrorMult*(mirrorM*2),
          mirrorMult*(mirrorM*2),
          mirrorMult*(mirrorM**2-1)
        ]
        for (var i = 0; i < s; i++) {
          inTileTransforms.push([
            inTileTransforms[i][0]*mirrorMatrix[0]+inTileTransforms[i][1]*mirrorMatrix[2],
            inTileTransforms[i][0]*mirrorMatrix[1]+inTileTransforms[i][1]*mirrorMatrix[3],
            inTileTransforms[i][2]*mirrorMatrix[0]+inTileTransforms[i][3]*mirrorMatrix[2],
            inTileTransforms[i][2]*mirrorMatrix[1]+inTileTransforms[i][3]*mirrorMatrix[3]
          ]);
        }
      }
    }
    function updateMirrorAngle(slope) {
      // console.trace(slope, typeof(slope));
      if (typeof(slope)=="undefined") {
        // console.log("a");
        mirrorM=mirrorAngleInputOptionsArr[curMirrorAngleInput][1](document.getElementById("mirror-angle-number-input-"+curMirrorAngleInput).value);
      }
      else {
        // console.log("b");
        mirrorM=slope;
      }

      // TODO: other schlafliP values should also be supported
      if (schlafliP==6) {//make mirrorM between 0 and ROOT3/6 (angle between 0 and 30deg)
        // TODO: fairly untested
        for (var i = 0; i < 2 && mirrorM>=1/ROOT3; i++) {
          mirrorM=(mirrorM-1/ROOT3)/(1+mirrorM/ROOT3);
        }
        for (var i = 0; i < 3 && mirrorM<0; i++) {
          mirrorM=(mirrorM+1/ROOT3)/(1-mirrorM/ROOT3);
        }

        // mirrorM=Math.abs(mirrorM);
        // if (mirrorM<0) {
        //   console.log("mirrorM<0");
        //   console.log(mirrorM);
        //   mirrorM=(mirrorM+ROOT3)/(1-mirrorM*ROOT3);
        //   console.log(mirrorM);
        // }
        // if (mirrorM<0) {
        //   mirrorM=(mirrorM+ROOT3)/(1-mirrorM*ROOT3);
        // }
        // if (mirrorM>ROOT3) {
        //   // console.log(mirrorM, Math.tan(Math.atan(mirrorM)-TAU/6));// TODO: not working
        //   // mirrorM=(mirrorM-ROOT3/2)/(1+mirrorM*ROOT3/2);
        //   mirrorM=1/ROOT3-4/(3*mirrorM+ROOT3);
        //   // mirrorM=Math.tan(Math.atan(mirrorM)-TAU/6);
        // }
        // else if (mirrorM>1/ROOT3) {
        //   // console.log(mirrorM, Math.tan(Math.atan(mirrorM)-TAU/6));// TODO: not working
        //   // mirrorM=(mirrorM-ROOT3/2)/(1+mirrorM*ROOT3/2);
        //   // mirrorM=4/(3*mirrorM+ROOT3)-1/ROOT3;
        //   mirrorM=(ROOT3-mirrorM)/(1+ROOT3*mirrorM);
        //   // mirrorM=Math.tan(Math.atan(mirrorM)-TAU/6);
        // }
        // console.log(mirrorM);
      }
      setInTileTransforms();
      clearAll();
    }

    // TODO: dynamically set as many as are needed with the current canvas size
    // TODO: scaling based on selected tiling (some euclidean tilings naturally appear bigger than others due to unit edge lengths and different polygons)
    function setTilingTransforms(name=tilingTypeName) {
      // console.trace("name:", name);
      if (!initialDrawingReady) return;
      switch (name) {
        case "none":
          // tilingTransforms=[new Affine2()];
          tilingTransforms=[new HypTransform()];
          break;
        case "hypTest":
          tilingTransforms=[
            new HypTransform(),
            // new HypTransform(0,0,0.01),
            new HypTransform(4, 3, 0),
            new HypTransform(0, 2.5, 0),
            // new HypTransform(0, 0.01, 0),
          ]
          break;
        case "regular using schlafli":// TODO: generalize with schlafli symbol input, then i can get rid of square, hex and tri
          // tilingTransforms=[];
          tilingTransforms=[new HypTransform()];
          
          // for (var i = 0; i < schlafliP; i++) {//only the central tile and its neighbors
          //   tilingTransforms.push(new HypTransform(TAU*(i+0.5)/schlafliP, 2*centerToEdgeMidpointHyp, PI+TAU*i/schlafliP));
          // }
          
          for (var i = 1; i < numPolys; i++) {
            if (true) {
            // if (P[i].layer==0 || P[i].layer==4) {
              tilingTransforms.push(new HypTransform(P[i].centerAngFromXAxis, P[i].centerToOriginHyp, P[i].vertexOffsetAngle));
            }
          }
          break;
        default:
          alert("this shouldn't have happened! (invalid tiling type)");
      }
      updateAutoGenerateButton();
    }
    function updateTilingType() {
      const rbs=document.querySelectorAll('input[name="tiling-type"]');// TODO: refactor
      for (const rb of rbs) {
        if (rb.checked) {
          tilingTypeName=rb.value;
          tilingTypeIndex=rb.id.slice(12);// TODO: kinda bad
          break;
        }
      }
      setTilingTransforms();
      clearAll();
    }

    function autoGenerateVerticesGeometrically(ctx=context) {//a geometrical (and unreliable) method of generating a snowflakes' vertices (using mirrorM) // TODO: i don't remember how this works, and it's currently broken
      if (!canAutoGenerateGeometrically()) return;
      // let transf=inTileTransforms;
      
      let transf=[
        inTileTransforms[9],
        inTileTransforms[10]
      ]
      // transf[3]=new Vec2();
      var pos=new Vec2(1/2, ROOT3/6);
      // drawPointAtPosition(pos);
      var curFlakeVertArr=[pos];
      var curFlakeMinimalVertArr=[pos];
      for (var ii = 0; ii < 2000; ii++) {
        var bestDist=Infinity;
        var bestPoint=new Vec2();
        drawPointAtPosition(pos);
        var tPoints=[];
        var tPointTransforms=[];
        for (var i = 0; i < transf.length; i++) {
          // console.log("%c"+i, "font-size:20px", transf[i]);
          var t=transf[i];
          tPoints.push(new Vec2(t[0]*pos.x+t[1]*pos.y, t[2]*pos.x+t[3]*pos.y));
          tPointTransforms.push(tPoints[i].add(new Vec2(1, 0)));
          // console.log("tPoints[i]", tPoints[i]);
          // var tPoints[i]=tPoints[i].add(new Vec2(tilingTransforms[1].x, tilingTransforms[1].y));
        }
        // TODO: This uses a loop over transf and a loop over tPoints, which could (and later should) be put into one loop, but it's currently like this for understandability/debugging purposes.
        for (var i = 0; i < tPoints.length; i++) {
          let isCopyOfACentralVertex=false;
          for (var vertIndex = 0; vertIndex < curFlakeVertArr.length; vertIndex++) {
            if (curFlakeVertArr[vertIndex].sqDist(tPoints[i])<0.000000001) {// TODO: use an epsilon
              isCopyOfACentralVertex=true;
              // console.log("%cCopy info:", "color:#f90; font-size:15px", curFlakeVertArr[vertIndex], tPoints[i]);
              break;
            }
          }
          if (!isCopyOfACentralVertex) {
            curFlakeVertArr.push(tPoints[i]);// TODO: only if not a copy
            // console.log("isCopy", isCopyOfACentralVertex);

            // // context.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).lighten(0.2).rgb();
            // // ctx.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).rgb();
            // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.mult(0.6).rgb();
            // // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : colorLerp(fillColorWithErase, ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1), 0.3).rgb();// TODO: tilingTransforms no longer working
            // // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.multColor(ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1)).rgb();
            // // ctx.fillStyle=fillColorWithErase.rgb();
            // // var offPoint=tPoints[i];
            // var offsetDist=1;
            // var offPoint=tPoints[i].add(new Vec2(offsetDist*tilingTransforms[sh].x, offsetDist*tilingTransforms[sh].y));
            //
            // // drawSquare(offPoint.x, offPoint.y, drawSize);
            // drawDisk(offPoint.x, offPoint.y, drawSize, ctx);

            if (tPointTransforms[i].len()<bestDist) {
              bestPoint=tPointTransforms[i];
              bestDist=tPointTransforms[i].len();
            }
          }
        }

        if (bestPoint.len()<0.000001) {// TODO: epsilon
          // console.log("Non-copying point not found (or some other problem)");
          break;
        }
        pos=bestPoint;
        curFlakeMinimalVertArr.push(bestPoint.copy());
      }
      // console.log(curFlakeVertArr);
      // console.log(curFlakeMinimalVertArr);
      // console.log(curFlakeMinimalVertArr.length);
      // console.log("%c..............................................................................................................", "background:#fff");
    }

    function drawPointAtPosition(pos, ctx=context) {//given a (unscreen) point, draw it in all symmetries. used mainly for user drawing
      // context.fillStyle="rgb(200, 200, 220)";
      // context.fillStyle="hsla("+lerp(getNoise(colorChangeSteps*colorChangeSpeed, 0.1, 1.5924), 100, 300)+", 80%, 70%, 0.3)";
      // context.fillStyle=fillColor;
      for (var i = 0; i < inTileTransforms.length; i++) {
        var t=inTileTransforms[i];
        var tPoint=new Vec2(t[0]*pos.x+t[1]*pos.y, t[2]*pos.x+t[3]*pos.y);
        // for (var sX = -1; sX < 2; sX++) {
        //   for (var sY = -1; sY < 2; sY++) {
        //     // context.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).lighten(0.2).rgb();
        //     // ctx.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).rgb();
        //     ctx.fillStyle= (sX==0 && sY==0) ? fillColorWithErase.rgb() : fillColorWithErase.mult(0.6).rgb();
        //     // ctx.fillStyle=fillColorWithErase.rgb();
        //     // var offPoint=tPoint;
        //     var offsetDist=1;
        //     var offPoint=tPoint.add(new Vec2(offsetDist*(sX+sY/2), offsetDist*sY*ROOT3/2));
        //
        //     // drawSquare(offPoint.x, offPoint.y, drawSize);
        //     drawDisk(offPoint.x, offPoint.y, drawSize, ctx);
        //   }
        // }
        for (var sh = 0; sh < tilingTransforms.length; sh++) {
          // context.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).lighten(0.2).rgb();
          // ctx.fillStyle= (sX==0 && sY==0) ? fillColor.rgb() : fillColor.mult(0.6).rgb();
          ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.mult(0.6).rgb();
          // console.log(ctx.fillStyle);
          // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : colorLerp(fillColorWithErase, ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1), 0.3).rgb();
          // ctx.fillStyle= (sh==0) ? fillColorWithErase.rgb() : fillColorWithErase.multColor(ColorFromHSL(tilingTransforms[sh].ang()/TAU, 1, 0.5, 1)).rgb();
          // ctx.fillStyle=fillColorWithErase.rgb();
          // var offPoint=tPoint;
          // var offPoint=tPoint.add(new Vec2(offsetDist*tilingTransforms[sh].x, offsetDist*tilingTransforms[sh].y));
          var offPoint=tilingTransforms[sh].applyTo(tPoint).mult(globalScaling);

          // if (sh==0) {
          //   drawSize+=2;
          // }
          // drawSquare(offPoint.x, offPoint.y, drawSize);
          drawDisk(offPoint.x, offPoint.y, drawSize, ctx);
          // if (sh==0) {
          //   drawSize-=2;
          // }
        }
      }
    }
    function drawAllPoints() {//draw everything that the user has drawn
      redrawBackground();
      let lastPosNum=0;
      let savedColor=fillColorWithErase;// TODO: everything here is bad
      let savedSize=drawSize;
      for (var i = 0; i <= curMovement; i++) {
        let posNum=movements[i];
        fillColorWithErase=movementColors[i];
        drawSize=movementSizes[i];
        for (var j = lastPosNum; j < posNum; j++) {
          drawPointAtPosition(mousePositions[j]);
        }
        lastPosNum=posNum;
      }
      fillColorWithErase=savedColor;
      drawSize=savedSize;
    }
    function drawFromCurDSF() {//draw the current DSF using .drawToWholeScreen() or make a list with curDSF and operations on it
      // TODO: controlled by user
      curDSF.drawToWholeScreen();
      // generateDSFGrid();
    }

    function drawHypGrid() {//draw a simple hyperbolic grid // TODO: jankiness could be lessened with homogenous coordinates
      context.fillStyle=BGColor.rgb();
      context.fillRect(0, 0, canvas.width, canvas.height);
      if (!isEuclidean) {//draw boundary circle
        context.strokeStyle=boundaryCircleColor;
        context.lineWidth=1.5;
        context.beginPath();
        context.arc(canvas.width/2, canvas.height/2, canvas.height/2, 0, TAU);
        context.stroke();
      }
      
      if (true) {//Draw edges for each polygon
        for (var i=numPolys-1; i>=0; i--) {//all polygons (reverse order)
          // for (var i=0; i<numPolys; i++) {//all polygons
          drawGridPoly(P[i].verts)
        }
      }
      drawAllVerts();
    }
    
    function update() {//main loop, runs every frame, handles user drawing
      if (!paused) {
        if (fReqs>=frameSkip) {
          changingContext.clearRect(0, 0, canvas.width, canvas.height);
          
          // let ctx=changingContext;
          // ctx.beginPath();
          // // ctx.fillStyle="#f0f";
          // ctx.strokeStyle="#f0f";
          // ctx.lineWidth=2;
          // let p1Ang=0; let p1Len=0;
          // let p2Ang=0; let p2Len=2;
          // // let p3Ang=2; let p3Len=1;
          // let a=p2Len;
          // let C=colorChangeSteps/20-2*TAU;
          // let b=2;
          //
          // let p3Ang=hypSASGetAngleAtFirstSide(a, C, b);
          // // console.log(p3Ang);
          // // if (p3Ang<0) {
          // //   p3Ang+=PI;
          // // }
          // // let p3Ang=1;
          // let p3Len=hypSASGetThirdEdge(a, C, b);
          // // let p3Len=1;
          //
          // let p1Vec=Vec2FromAngleAndHypLength(p1Ang, p1Len);
          // let p2Vec=Vec2FromAngleAndHypLength(p2Ang, p2Len);
          // let p3Vec=Vec2FromAngleAndHypLength(p3Ang, p3Len);
          // let p1Screen=p1Vec.screen();
          // // let p2Screen=p2Vec.screen();
          // // let p3Screen=p3Vec.screen();
          // ctx.moveTo(p1Screen.x, p1Screen.y);
          // pathPoincareEdge(p2Vec, p1Vec, ctx);
          // pathPoincareEdge(p3Vec, p2Vec, ctx);
          // pathPoincareEdge(p1Vec, p3Vec, ctx);
          // ctx.stroke();
          
          // curDSF.segmentLength=(-colorChangeSteps/500%1+1)%1 *0.1;
          // drawFromCurDSF();
          
          // let mouseScreenPos=mousePos.unscreen();//mouse position, no longer in screen coordinates
          let mouseScreenPos=mousePos.unscreen().div(globalScaling);//mouse position, no longer in screen coordinates // TODO: rename
          if (mouseDown) {
            // fReqs=0;
            // console.log(fReqs);
            
            // for (var i = 0; i < 20; i++) {
            //   if (true) {//do calculations
            //     mouseScreenPos=mouseScreenPos.add(new Vec2(rand0(maxStep), rand0(maxStep))).mult(distFactor);
            //   }
            //   draw();// TODO: this commented block could be fixed, but is it useful? (btw draw probably needs to be outside the for)
            //   colorChangeSteps++;
            // }
            
            mousePositions.push(mouseScreenPos);
            drawPointAtPosition(mouseScreenPos);
            // colorChangeSteps++;
          }
          else {
            drawPointAtPosition(mouseScreenPos, changingContext);
          }
          
          colorChangeSteps++;
          fReqs-=frameSkip; // TODO: i think this will work
        }
        fReqs++;
        window.requestAnimationFrame(update);
      }
    }

    function updateSchlafliSymbol() {//set schlafliSymbol from the schlafliInputContainer, change dependent variable
      let newSchlafliSymbol=[parseInt(document.getElementById("schlafliP").value), parseInt(document.getElementById("schlafliQ").value)];// TODO: no getElementById
      let schlafliSymbolChanged=true;
      if( //if the input values are reasonable, change variables accordingly
          newSchlafliSymbol[0]>=3 && newSchlafliSymbol[0]<=30
          && newSchlafliSymbol[1]>=3 && newSchlafliSymbol[1]<=30
          && (newSchlafliSymbol[0]-2)*(newSchlafliSymbol[1]-2)>=4
        )
        {// TODO: change arbitrary limits (particularly upper ones) // TODO: allow spherical geometry too!
          schlafliInputContainer.style.backgroundColor="";// TODO: use a global element variable instead of getElementById
          if (arraysShallowEqual(schlafliSymbol, newSchlafliSymbol)) schlafliSymbolChanged=false;
          schlafliSymbol=newSchlafliSymbol;
          schlafliP=schlafliSymbol[0];
          schlafliQ=schlafliSymbol[1];
        }
        else {
          schlafliInputContainer.style.backgroundColor="rgb(240, 80, 80)";
        }
        
      if (schlafliSymbolChanged) {
        generateHyperbolicGraph();
        setInTileTransforms();
        setTilingTransforms();
        setDSFStuff();
        clearAll();
      }
      return schlafliSymbolChanged;
    }
    function generateHyperbolicGraph() {//generate V and P, the vertexes and polygons of the hyperbolic grid
      // TODO: where is this all from? (i figured a lot of it out, but there must be something to cite)
      // TODO: redefine objects only when schlafliSymbol changes
      if (true){// INITIAL object definition (first polygon and vertices with positions)
        P=[new Polygon()];//Polygons array
        V=[];//Vertices array
        for (var i = 0; i < schlafliP; i++)
          V[i]=new Vert();
        for (var i = 0; i < schlafliP; i++) {
          P[0].addVert(i);
          V[i].addPoly(0);
          V[i].addNext((i+1)%schlafliP);
          V[(i+1)%schlafliP].addNext(i);
        }
        numVerts=schlafliP;
        numPolys=1;

        let d;
        if ((schlafliP-2)*(schlafliQ-2)>4) {
          isEuclidean=false;
          d=Math.sqrt((Math.tan(PI / 2 - PI / schlafliQ) - Math.tan(PI / schlafliP)) / (Math.tan(PI / 2 - PI / schlafliQ) + Math.tan(PI / schlafliP)));
          
          //formula taken from http://www.malinc.se/noneuclidean/en/poincaretiling.php#formula on 16.07.2021
          centerToVertexEuc=d;
          
          // TODO: where is this from? // TODO: rename, it's hyperbolic, not just poincare
          edgeLengthHyp=Math.acosh(1+2*((1-Math.cos(TAU/schlafliP))**2+Math.sin(TAU/schlafliP)**2)*(radius*d)**2/( (radius**2-d**2)**2 ));
          
          centerToEdgeMidpointEuc=hypToEucDist(hypSASGetThirdEdge(eucToHypDist(centerToVertexEuc), PI/schlafliQ, edgeLengthHyp/2));
        }
        else if ((schlafliP-2)*(schlafliQ-2)==4) {
          isEuclidean=true;
          // d=0.1;
          
          // centerToVertexEuc=d;
          centerToVertexEuc=0.5/Math.sin(PI/schlafliP);
          // console.log(centerToVertexEuc);
          
          // centerToEdgeMidpointEuc=0.41;
          centerToEdgeMidpointEuc=0.5/Math.tan(PI/schlafliP);
          
          // TODO: what's the plan here? i don't remember what that edgeLengthHyp formula is
          // edgeLengthHyp=d*Math.sqrt(2*(1-Math.cos(TAU/schlafliP)));
          edgeLengthHyp=1;
        }
        // console.log(d, edgeLengthHyp);
        
        centerToVertexHyp=eucToHypDist(centerToVertexEuc);
        centerToEdgeMidpointHyp=eucToHypDist(centerToEdgeMidpointEuc);
        
        for (var i=0; i<schlafliP; i++) {//first polygon position
          // let offsetAng=0; let offsetX=0.02; let offsetY=0.01;//c++ version, causes problems near borders
          // let offsetAng=0; let offsetX=0.001; let offsetY=0.002;//stable
          // let offsetAng=0.001; let offsetX=0.0001; let offsetY=0.00002;//extra stable?
          // let offsetAng=0.05; let offsetX=0; let offsetY=0;//newly stable
          let offsetAng=0.0000000001; let offsetX=0; let offsetY=0;//newly stable? (doesn't work for metasquares polygon checking)
          // let offsetAng=0; let offsetX=0; let offsetY=0;// TODO: why doesn't it work?

          // let offsetAng=0.001; let offsetX=0; let offsetY=0;

          V[i].setPos(new Vec2(radius*d*Math.cos(i*TAU/schlafliP+offsetAng)+offsetX, -radius*d*Math.sin(i*TAU/schlafliP+offsetAng)+offsetY));
        }
      }
      // for (var k=0; k<2; k++) {// GRAPH generation
      // for (var k=0; k<1+schlafliP+50; k++) {// GRAPH generation
      for (var k=0; k<1+schlafliP; k++) {// GRAPH generation
        // for (var i=0; i<0; i++) {//edges
        for (var i=0; i<schlafliP; i++) {//edges
          //don't make new polygon towards parent
          if (P[k].numNext>0 && i==0) continue;
          //get first 2 vertices of new polygon
          var v1=P[k].verts[(1+i)%schlafliP];
          var v2=P[k].verts[i];

          if (V[v1].numPolys==schlafliQ || V[v2].numPolys==schlafliQ) continue;

          P[numPolys]=new Polygon();
          P[numPolys].layer=P[k].layer+1;

          //neighborship of new polygon and its parent
          P[k].addNext(numPolys);
          P[numPolys].addNext(k);

          //add 2 vertices of first polygon to new polygon and vice versa
          P[numPolys].addVert(v1);
          P[numPolys].addVert(v2);
          V[v1].addPoly(numPolys);
          V[v2].addPoly(numPolys);

          var makeV3=(V[v2].numNext<schlafliQ);
          var makeV4=(V[v1].numNext<schlafliQ);

          var vertArc=[];
          if (makeV3) {
            vertArc.push(v2);
          }
          else {
            vertArc.push(V[v2].next[V[v2].numNext-1]);//make efficient (not V[v2].numNext but schlafliQ or something) (elsewhere similarly)

            V[vertArc[0]].addPoly(numPolys);
            P[numPolys].addVert(vertArc[0]);

            P[V[v2].polys[V[v2].numPolys-2]].addNext(numPolys);
            P[numPolys].addNext(V[v2].polys[V[v2].numPolys-2]);
          }

          for (var j = 4-makeV3-makeV4; j < schlafliP; j++) {
            var newVert=numVerts;
            V[newVert]=new Vert();
            vertArc.push(newVert);
            V[newVert].addPoly(numPolys);
            P[numPolys].addVert(newVert);
            numVerts++;
          }

          if (makeV4) {
            vertArc.push(v1);
          }
          else {
            vertArc.push(V[v1].next[V[v1].numNext-1]);

            V[vertArc[vertArc.length-1]].addPoly(numPolys);
            P[numPolys].addVert(vertArc[vertArc.length-1]);

            P[V[v1].polys[V[v1].numPolys-2]].addNext(numPolys);
            P[numPolys].addNext(V[v1].polys[V[v1].numPolys-2]);
          }

          for (var j = 1; j < vertArc.length; j++) {
            V[vertArc[j]].addNext(vertArc[j-1]);
            V[vertArc[j-1]].addNext(vertArc[j]);
          }

          numPolys++;
        }
      }
      for (var i=0; i<numVerts; i++) {// ORDER the vertices
        let curV=V[i];
        var j=0;
        for (; j < curV.polys.length; j++) {
          let curPoly=P[curV.polys[j]];
          // console.log("curPoly", curV.polys[j]);
          let vertArr=curPoly.verts;
          let curVLocalIndex=indexOfElement(vertArr, i);
          // let widdVert=vertArr[(curVLocalIndex-1+schlafliP)%schlafliP];
          let widdVert=vertArr[(curVLocalIndex+1)%schlafliP];
          // console.log(widdVert);
          let k=0;
          for (; k < curV.polys.length; k++) {
            if (arrayContains(P[curV.polys[k]].verts, widdVert) && j!=k) {
              break;
            }
          }
          if (k==curV.polys.length) {
            // console.log("begin at", curV.polys[j]);
            break;
          }
          else {
            // console.log("ok");
          }
        }

        let newNextArr=[];
        let newPolyArr=[];
        let curPairIndex=j;
        if (curPairIndex==curV.polys.length) {
          curPairIndex=0;
        }
        let pairs=[];
        let firstPairIndex=curPairIndex;

        for (var j=0; j < curV.polys.length; j++) {
          let curPoly=P[curV.polys[j]];
          // console.log(curPolyIndex, curV.polys[curPolyIndex]);
          // console.log("curPoly", curV.polys[j]);
          let vertArr=curPoly.verts;
          let curVLocalIndex=indexOfElement(vertArr, i);
          let widdVert=vertArr[(curVLocalIndex-1+schlafliP)%schlafliP];
          let clockVert=vertArr[(curVLocalIndex+1)%schlafliP];
          // pairs.push([widdVert, clockVert]);
          pairs.push([clockVert, widdVert, curV.polys[j]]);
          // console.log(widdVert);
          // let k=0;
          // for (; k < curV.polys.length; k++) {
          //   if (arrayContains(P[curV.polys[k]].verts, widdVert) && j!=k) {
          //     break;
          //   }
          // }
          // if (k!=curV.polys.length) {//another polygon with the 2 vertices was found
          //   if () {
          //   }
          //   else {
          //     newNextArr.push(widdVert);
          //     newPolyArr.push(curV.polys[k]);
          //     curPolyIndex=k;
          //   }
          // }
          // else {
          //   newNextArr.push(vertArr[(curVLocalIndex+1)%schlafliP]);
          //   break;
          // }
        }

        // console.log(pairs);

        while (curPairIndex!=firstPairIndex || newNextArr.length==0) {
          let curPair=pairs[curPairIndex];
          // console.log(curPairIndex, curPair);
          newNextArr.push(curPair[0]);
          newPolyArr.push(curPair[2]);
          for (var k=0; k < pairs.length; k++) {
            if (pairs[k][0]==curPair[1]) {
              curPairIndex=k;
              break;
            }
          }
          if (k==pairs.length) {
            newNextArr.push(curPair[1]);
            break;
          }
        }

        // console.log("!!result!!", newNextArr, newPolyArr);

        curV.next=newNextArr;
        curV.polys=newPolyArr;

        // for (var j=0; j < curV.polys.length; j++) {
        //   let curPoly=P[curV.polys[curPolyIndex]];
        //   console.log(curPolyIndex, curV.polys[curPolyIndex]);
        //   // console.log("curPoly", curV.polys[j]);
        //   let vertArr=curPoly.verts;
        //   let curVLocalIndex=indexOfElement(vertArr, i);
        //   let widdVert=vertArr[(curVLocalIndex-1+schlafliP)%schlafliP];
        //   // console.log(widdVert);
        //   let k=0;
        //   for (; k < curV.polys.length; k++) {
        //     if (arrayContains(P[curV.polys[k]].verts, widdVert) && j!=k) {
        //       break;
        //     }
        //   }
        //   if (k!=curV.polys.length) {//another polygon with the 2 vertices was found
        //     if () {
        //     }
        //     else {
        //       newNextArr.push(widdVert);
        //       newPolyArr.push(curV.polys[k]);
        //       curPolyIndex=k;
        //     }
        //   }
        //   else {
        //     newNextArr.push(vertArr[(curVLocalIndex+1)%schlafliP]);
        //     break;
        //   }
        // }

        // let k=0;
        // let lastK=undefined;
        // let lastPoly=curV.polys[0];
        // let newNextArr=[];
        // let newPolysArr=[0];
        // do {
        //   let vertArr=P[lastPoly].verts;//verts array of the first parent polygon
        //   let lastVert=vertArr[(indexOfElement(vertArr, i)-1+schlafliQ)%schlafliQ];
        //   k=0;
        //   for (; k < curV.numPolys; k++) {//find another polygon with curV and last found vertex as its vertices
        //     // console.log(P[curV.polys[k]].verts, lastVert);
        //     if (arrayContains(P[curV.polys[k]].verts, lastVert) && k!=lastK) {
        //       break;
        //     }
        //   }
        //
        //   if (k==curV.numPolys) {
        //     console.log("bad!!!!!!!!!!!!!!!!");
        //     break;
        //   }
        //   else {
        //     lastPoly=curV.polys[k];
        //     newPolysArr.push(lastPoly)
        //   }
        //   lastK=k;
        // } while (k!=0)
        //
        // console.log(i);
        // // console.log(curV.next);
        // // console.log(newNextArr);
        // console.log(curV.polys);
        // console.log(newPolysArr);

        // let newNextArr=[];
        // let vertArr=P[curV.polys[0]].verts;//verts array of the first parent polygon
        // let lastVert=V[vertArr[(indexOfElement(vertArr, curV)-1+schlafliQ)%schlafliQ]];
        // while (true) {
        //   newNextArr.push(lastVert);
        //   vertArr=P[curV.polys[lastVert]].verts;//verts array of one of the parent polygons
        //   // newNextArr.push(vertArr[(indexOfElement(vertArr, i)-1+schlafliQ)%schlafliQ]);//get the element after curV in vertArr, add it to newNextArr
        //   var k=0;
        //   for (; k < curV.numPolys; k++) {//find another polygon with curV and last found vertex as its vertices
        //     if (arrayContains(P[curV.polys[k]].verts, newNextArr[newNextArr.length-1]) && k!=j) {
        //       break;
        //     }
        //   }
        //   if (k==curV.numPolys) {
        //     console.log("bad!!!!!!!!!!!!!!!!");
        //     break;
        //   }
        //   else {
        //
        //   }
        //   let vertArr=P[curV.polys[0]].verts;
        //   let lastVert=V[vertArr[(indexOfElement(vertArr, curV)-1+schlafliQ)%schlafliQ]];
        //   console.log(indexOfElement(vertArr, i), (indexOfElement(vertArr, i)+1)%schlafliQ);
        // }
        // console.log(curV.next, newNextArr);
        // console.log("");
      }
      for (var i=1; i<numPolys; i++) {// CALCULATE vertex positions
        // console.log("%c"+P[i].next[0]+":", "font-size:160%; color:lime", i);
        let v1=P[i].verts[0];
        let v2=P[i].verts[1];
        let parentPoly=P[P[i].next[0]];
        
        // centerAngFromXAxis, centerToOriginHyp, vertexOffsetAngle
        let parentVertIndex=indexOfElement(parentPoly.verts, P[i].verts[0]);
        // let angleOriginToParentToChild=-PI-parentPoly.centerAngFromXAxis+(0.5-parentVertIndex)*TAU/schlafliP+parentPoly.vertexOffsetAngle;
        let angleOriginToParentToChild=-PI-parentPoly.centerAngFromXAxis+(0.5001-parentVertIndex)*TAU/schlafliP+parentPoly.vertexOffsetAngle;// TODO: something dislikes precise angles (in [6, 4], [8, 4], [10, 3])
        // let angleOriginToParentToChild=(parentVertIndex+0.5)*TAU/schlafliP+P[k].vertexOffsetAngle;// TODO: won't work, it's a simplified version of the above line
        // console.log("parentPoly.centerAngFromXAxis", parentPoly.centerAngFromXAxis, "parentVertIndex", parentVertIndex, "(1.5-parentVertIndex)*TAU/schlafliP", (1.5-parentVertIndex)*TAU/schlafliP, "parentPoly.vertexOffsetAngle", parentPoly.vertexOffsetAngle, "angleOriginToParentToChild", mod(angleOriginToParentToChild, TAU));
        // console.log("angleOriginToParentToChild", angleOriginToParentToChild);
        if (i<=schlafliP) {//the surrounding of the first tile // TODO: shouldn't be necessary, here for bugfixing
        // if (false) {
          P[i].centerAngFromXAxis=(0.5-i)*TAU/schlafliP;
          P[i].centerToOriginHyp=2*centerToEdgeMidpointHyp;
          // P[i].vertexOffsetAngle=PI+TAU*i/schlafliP;
          P[i].vertexOffsetAngle=PI+TAU*(1-i)/schlafliP;
          // console.log(P[i].centerAngFromXAxis);
          // console.log(i, P[i].next[0], P[i].vertexOffsetAngle);
        }
        else {
          P[i].centerAngFromXAxis=parentPoly.centerAngFromXAxis-hypSASGetAngleAtFirstSide(parentPoly.centerToOriginHyp, angleOriginToParentToChild, 2*centerToEdgeMidpointHyp);
          P[i].centerToOriginHyp=hypSASGetThirdEdge(parentPoly.centerToOriginHyp, angleOriginToParentToChild, 2*centerToEdgeMidpointHyp);
          
          // P[i].vertexOffsetAngle=0;
          P[i].vertexOffsetAngle=new HypTransform(P[i].centerAngFromXAxis, -P[i].centerToOriginHyp).applyTo(V[P[i].verts[0]].pos).ang();
          
          // console.log("angleOriginToParentToChild", mod(angleOriginToParentToChild, TAU));
          // console.log(i, P[i].next[0], P[i].centerToOriginHyp);
        }

        let prevC, newR;

        if (!isEuclidean) {//calculate circle center
          let scaleM=(radius**2/V[v1].pos.sqLen() + 1)/2;
          let scaleN=(radius**2/V[v2].pos.sqLen() + 1)/2;
          let M=new Vec2(V[v1].pos.x*scaleM, V[v1].pos.y*scaleM);
          let N=new Vec2(V[v2].pos.x*scaleN, V[v2].pos.y*scaleN);
          // let centerY=(M.x*(M.x-N.x-N.y*N.y/N.x)+M.y*M.y)/(M.y-N.y*M.x/N.x);//mostly works, but has division by N.x
          let centerY=(M.x*(M.x*N.x-N.x*N.x-N.y*N.y)+M.y*M.y*N.x)/(M.y*N.x-N.y*M.x);

          prevC=new Vec2(M.x+M.y*(M.y-centerY)/M.x, centerY);
          newR=(prevC.sub(V[v1].pos)).len();

          // TODO: prevC.x breaks when offsetAng is a multiple of HPI
          // console.log(prevC);
          // console.log("M", M);
          // console.log(M.y*(M.y-centerY)/M.x);
          // console.log(M.y, "*", (M.y-centerY)/M.x, "=", M.y*((M.y-centerY)/M.x));
          // console.log(V[v1].pos);console.log(V[v2].pos);
          // console.log(prevC);
          // console.log(prevC.len());
          // console.log("");
        }

        if (isEuclidean || prevC.len()>10000) {//mirror across a line
          for (var j=2; j<schlafliP; j++) {
            let newV=P[i].verts[j];
            let normalI=V[parentPoly.verts[(indexOfElement(parentPoly.verts, v1)-j+schlafliP)%schlafliP]].pos;//point to be mirrored, to get another position

            let s=V[v2].pos.sub(V[v1].pos);
            let k=V[v1].pos.sub(normalI);

            let invertedI=V[v1].pos.mult(2).sub(normalI).sub(s.mult(2*(k.x*s.x+k.y*s.y)/(s.x*s.x+s.y*s.y)));
            V[P[i].verts[j]].setPos(invertedI);
          }
        }
        else {//mirror with circle inversion
          for (var j=2; j<schlafliP; j++) {
            let newV=P[i].verts[j];
            let normalI=V[parentPoly.verts[(indexOfElement(parentPoly.verts, v1)-j+schlafliP)%schlafliP]].pos;//point to be mirrored, to get another position
            let prevCToNormalI=normalI.sub(prevC);
            let invertedI=prevC.add(prevCToNormalI.mult((newR/prevCToNormalI.len())**2));

            // console.log(invertedI);
            // context.strokeStyle=new Color(randRange(30, 256), randRange(30, 256), randRange(30, 256)).rgb();
            // // context.strokeStyle="rgb(200, 200, 200)";
            // context.lineWidth=1;
            // var prevCScreen=prevC.screen();
            // context.beginPath();
            // context.arc(prevCScreen.x, prevCScreen.y, newR*height/2, 0, TAU);
            // context.stroke();

            V[P[i].verts[j]].setPos(invertedI);
          }
        }

      }
      // /* DEBUG (dump graph info) */
      // for (var i=0; i<numVerts; i++) {
      //   console.log("V[" + i + "]");
      //   console.log("Adjacent vertices:", V[i].next);
      //   console.log("Polygons:", V[i].polys);
      //   console.log(round(V[i].pos.x), round(V[i].pos.y));
      //   console.log("");
      // }
      // console.log(""); console.log("");
      // for (var i=0; i<numPolys; i++) {
      //   console.log("P[" + i + "]");
      //   console.log("Adjacent polygons:", P[i].next);
      //   console.log("Vertices:", P[i].verts);
      //   console.log("");
      // }
      // console.log("numVerts", numVerts);
      // console.log("numPolys", numPolys);
            
      // setTilingTransforms();
    }
    
    function setDSFStuff() {//update the segment length and mirrorM, used when the schlafli symbol changes or the word mode is switched to // TODO: rename
      curDSF.updateSegmentLength();
      curDSF.updateMirrorM();
    }
    
    // function restart() {
    //   clearAll();
    //
    //   // updateSchlafliSymbol();
    //
    //   // drawHypGrid();
    //   // drawFromCurDSF();
    // }
    
    function redrawBackground() {//clear the screen and draw whatever background elements have been selected. May draw curDSF or a simple hyperbolic grid
      context.clearRect(0, 0, canvas.width, canvas.height);
      if (initialDrawingReady) {
        // drawHypGrid();
        if (wordModeEnabled) {
          drawFromCurDSF();
        }
      }
    }
    
    function redrawAll() {//clear the screen, redraw the background and user drawn points
      redrawBackground();
      drawAllPoints();
    }
    
    function clearAll() {
      redrawBackground();
      
      mousePositions=[];
      movements=[];
      movementColors=[];
      movementSizes=[];
      curMovement=-1;
      // autoGenerateVerticesGeometrically();
    }
    function resizeWithWait() {
      if (framesSinceResize<minFramesSinceResize) {
        framesSinceResize++;
        window.requestAnimationFrame(resizeWithWait);
      }
      else {
        if (resizeRequested) {
          resize();
          resizeRequested=false;
        }
        framesSinceResize=0;
      }
    }
    function resize() {
      canvas.width=changingCanvas.width=window.innerWidth;
      height=canvas.height=changingCanvas.height=window.innerHeight;
      context.lineJoin="round";// TODO: probably not needed
      context.lineCap="round";
      redrawAll();
    }
        
    // updateTilingType();
    
    initialDrawingReady=true;
    
    setInTileTransforms();
    generateHyperbolicGraph();
    
    updateSchlafliSymbol();
    
    setWordModeEnabled(false);
    
    resizeWithWait();
    
    redrawBackground();
    
    update();



    function mouseUp(){
      if (mouseDown) {
        mouseDown=false;
        movementColors.push(fillColorWithErase);
        movementSizes.push(drawSize);
        fillColorWithErase=fillColor;
        movements.push(mousePositions.length);
      }
    }
    function selectFillColor(c) {
      fillColor=fillColorWithErase=c;
    }

    window.addEventListener("mousemove", function() {
      // if (!paused) {
        // mousePos.x=event.clientX;
        // mousePos.y=event.clientY;
        mousePos=new Vec2(
          (event.clientX+mousePos.x*mouseSlowingFactor)/(mouseSlowingFactor+1),
          (event.clientY+mousePos.y*mouseSlowingFactor)/(mouseSlowingFactor+1)
        );
      // }
    });
    changingCanvas.oncontextmenu = function() { return false; }//so that right clicking doesn't open a menu
    changingCanvas.onmousedown = function() {
      mouseDown=true;
      if (event.buttons==1) {//RMB, draw
        fillColorWithErase=fillColor;
      }
      else if (event.buttons==2) {//LMB, erase
        fillColorWithErase=BGColor;
      }
      else {//multiple buttons or a weird button has been pressed, pretend the mouse was released
        mouseUp();
        return;
      }
      curMovement++;
    }
    changingCanvas.onmouseup = mouseUp;

    window.addEventListener("keyup", function() {
      var curKey=event.keyCode;
      keys[curKey]=false;
      // console.log(keys);
    });
    window.addEventListener("keydown",function(){
      var curKey=event.keyCode;
      keys[curKey]=true;
      // console.log(keys);
      // console.log(curKey);
      switch (curKey) {
        case 32://space - pause
          paused=!paused;
          if (paused) {
            // console.log("Paused");
            dropBtn.innerHTML="⏸";
            changingCanvas.style.display="none";
          }
          else {
            // console.log("Unpaused");
            update();
            dropBtn.innerHTML="";
            changingCanvas.style.display="";
          }
          break;
        case 68://d - draw hyperbolic grid // TODO:
          drawHypGrid();
          break;
        case 82://r - clear all
          clearAll();
          break;
        case 90://z - undo
          if (curMovement>=0) {
            mouseUp();
            curMovement--;
            let lastMovementVal=movements.pop();
            movementColors.pop();
            movementSizes.pop();
            let curMovementVal=movements.length==0 ? 0 : movements[movements.length-1];
            mousePositions.splice(curMovementVal, lastMovementVal-curMovementVal);
          };
          drawAllPoints();
          break;
      }
    });
    window.addEventListener("resize", function() {
      if (!resizeRequested) {
        resizeRequested=true;
        resizeWithWait();
      }
    });
  </script>
</body>
</html>
